# JS: Архитектура фронтенда [[hexlet](https://ru.hexlet.io/courses/js-frontend-architecture)]


## Состояние приложения
* Событийная архитектура и DOM без должного внимания порождают запутанный код буквально сразу
* Необходимость базы данных довольно очевидна и понятна для всех, но то же самое не очевидно во фронтенде. DOM позволяет хранить состояние внутри себя и, более того, провоцирует так делать. Главная проблема такого подхода в отсутствии единого источника правды.
* Первый шаг в построении правильной архитектуры состоит в выделении данных которыми манипулирует приложение из DOM в отдельную переменную на уровне приложения. Это позволит отделить работу с данными от их отображения.
* Дополнительные материалы:
  * [Скрипты, модули и библиотеки](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/state/exercise_unit)
  * [Совершенный код: состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)


## Комплексное состояние
* Cостояние — это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере
* В приложениях далеко не все данные могут изменяться с течением времени. К таким данным может относиться конфигурация, например таймауты, различные ключи доступа или настройки библиотек. Такие данные (можно сказать что они статические) в состоянии не хранят. Достаточно иметь отдельные константы созданные прямо по месту использования, либо импортируемые из специального модуля с настройками
* Само состояние лучше всего организовывать в виде одной константы содержащей объект. За таким объектом гораздо проще следить, чем за набором разных констант или переменных
* Частая ошибка при формировании состояния, привязка структуры состояния к визуальному оформлению. Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придётся править
* Состояние приложения это данные, а не их отображение. Поэтому хранение DOM-элементов в состоянии считается плохой практикой. Фактически это возврат к структуре до введения состояния, когда данные хранились внутри представления
* Дополнительные материалы:
  * [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)


## Отрисовка (рендеринг) состояния
* Обновление внешнего вида на основе состояния, обычно, выносят в отдельный слой, который называется представлением (View). В простейшем случае представлением является функция, которая принимает на вход состояние, анализирует его и производит необходимые изменения в DOM.
* С ростом приложения увеличивается и количество обработчиков. Каждый из них может приводить к изменению только части страницы. 
* Наиболее простым решением будет привязка таких функций к элементам состояния. Предположим что у нас есть страница управления списком уроков в курсе.
* Для отрисовки этого списка подойдет одна функция `renderLessons()`, которая будет вызываться во всех обработчиках изменяющих этот список: удаляющих или добавляющих элементы.
* Что происходит внутри этой функции? Кажется что внутри функции рендеринга нужно определять что произошло и, затем, менять необходимую часть дома, например, удалить какой-то элемент, которого больше нет. В реальности это очень затратный подход, его сложно программировать, так как появляется большое количество условных конструкций. Намного проще выполнять полную перерисовку в любой ситуации. Тогда код останется максимально простым.
* Теперь наше приложение разделено на три независимых части: состояние (данные приложения), обработчики и рендеринг.
* Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют:
  * Состояние не знает ничего про остальные части системы — оно ядро.
  * Рендеринг пользуется состоянием для отрисовки и добавляет новые обработчики в DOM
  * Обработчики знают про состояние, так как обновляют его и инициируют рендеринг


## Состояние отображения (UI State)
* Изменение состояния фронтенд-приложения не всегда означает изменение данных, с которыми работает приложение. У данных может быть состояние, которое влияет только на внешний вид. На сервере, в базе данных, такое состояние отсутствует.
* UI-состояние хранят отдельно от самих данных.


##
* 
* 
* 
* 
* 
* 
