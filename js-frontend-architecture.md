# JS: Архитектура фронтенда [[hexlet](https://ru.hexlet.io/courses/js-frontend-architecture)]


## Состояние приложения
* Событийная архитектура и DOM без должного внимания порождают запутанный код буквально сразу
* Необходимость базы данных довольно очевидна и понятна для всех, но то же самое не очевидно во фронтенде. DOM позволяет хранить состояние внутри себя и, более того, провоцирует так делать. Главная проблема такого подхода в отсутствии единого источника правды.
* Первый шаг в построении правильной архитектуры состоит в выделении данных которыми манипулирует приложение из DOM в отдельную переменную на уровне приложения. Это позволит отделить работу с данными от их отображения.
* Дополнительные материалы:
  * [Скрипты, модули и библиотеки](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/state/exercise_unit)
  * [Совершенный код: состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)


## Комплексное состояние
* Cостояние — это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере
* В приложениях далеко не все данные могут изменяться с течением времени. К таким данным может относиться конфигурация, например таймауты, различные ключи доступа или настройки библиотек. Такие данные (можно сказать что они статические) в состоянии не хранят. Достаточно иметь отдельные константы созданные прямо по месту использования, либо импортируемые из специального модуля с настройками
* Само состояние лучше всего организовывать в виде одной константы содержащей объект. За таким объектом гораздо проще следить, чем за набором разных констант или переменных
* Частая ошибка при формировании состояния, привязка структуры состояния к визуальному оформлению. Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придётся править
* Состояние приложения это данные, а не их отображение. Поэтому хранение DOM-элементов в состоянии считается плохой практикой. Фактически это возврат к структуре до введения состояния, когда данные хранились внутри представления
* Дополнительные материалы:
  * [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)
