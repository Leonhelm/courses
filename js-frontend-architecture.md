# JS: Архитектура фронтенда [[hexlet](https://ru.hexlet.io/courses/js-frontend-architecture)]


## Состояние приложения
* Событийная архитектура и DOM без должного внимания порождают запутанный код буквально сразу
* Необходимость базы данных довольно очевидна и понятна для всех, но то же самое не очевидно во фронтенде. DOM позволяет хранить состояние внутри себя и, более того, провоцирует так делать. Главная проблема такого подхода в отсутствии единого источника правды.
* Первый шаг в построении правильной архитектуры состоит в выделении данных которыми манипулирует приложение из DOM в отдельную переменную на уровне приложения. Это позволит отделить работу с данными от их отображения.
* Дополнительные материалы:
  * [Скрипты, модули и библиотеки](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/state/exercise_unit)
  * [Совершенный код: состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)


## Комплексное состояние
* Cостояние — это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере
* В приложениях далеко не все данные могут изменяться с течением времени. К таким данным может относиться конфигурация, например таймауты, различные ключи доступа или настройки библиотек. Такие данные (можно сказать что они статические) в состоянии не хранят. Достаточно иметь отдельные константы созданные прямо по месту использования, либо импортируемые из специального модуля с настройками
* Само состояние лучше всего организовывать в виде одной константы содержащей объект. За таким объектом гораздо проще следить, чем за набором разных констант или переменных
* Частая ошибка при формировании состояния, привязка структуры состояния к визуальному оформлению. Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придётся править
* Состояние приложения это данные, а не их отображение. Поэтому хранение DOM-элементов в состоянии считается плохой практикой. Фактически это возврат к структуре до введения состояния, когда данные хранились внутри представления
* Дополнительные материалы:
  * [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)


## Отрисовка (рендеринг) состояния
* Обновление внешнего вида на основе состояния, обычно, выносят в отдельный слой, который называется представлением (View). В простейшем случае представлением является функция, которая принимает на вход состояние, анализирует его и производит необходимые изменения в DOM.
* С ростом приложения увеличивается и количество обработчиков. Каждый из них может приводить к изменению только части страницы. 
* Наиболее простым решением будет привязка таких функций к элементам состояния. Предположим что у нас есть страница управления списком уроков в курсе.
* Для отрисовки этого списка подойдет одна функция `renderLessons()`, которая будет вызываться во всех обработчиках изменяющих этот список: удаляющих или добавляющих элементы.
* Что происходит внутри этой функции? Кажется что внутри функции рендеринга нужно определять что произошло и, затем, менять необходимую часть дома, например, удалить какой-то элемент, которого больше нет. В реальности это очень затратный подход, его сложно программировать, так как появляется большое количество условных конструкций. Намного проще выполнять полную перерисовку в любой ситуации. Тогда код останется максимально простым.
* Теперь наше приложение разделено на три независимых части: состояние (данные приложения), обработчики и рендеринг.
* Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют:
  * Состояние не знает ничего про остальные части системы — оно ядро.
  * Рендеринг пользуется состоянием для отрисовки и добавляет новые обработчики в DOM
  * Обработчики знают про состояние, так как обновляют его и инициируют рендеринг


## Состояние отображения (UI State)
* Изменение состояния фронтенд-приложения не всегда означает изменение данных, с которыми работает приложение. У данных может быть состояние, которое влияет только на внешний вид. На сервере, в базе данных, такое состояние отсутствует.
* UI-состояние хранят отдельно от самих данных.


## Процессы и автоматы, их описывающие
* В идеале, любые изменения в интерфейсе являются следствием изменения данных, то есть состояния приложения.
* Проблема флагоориентированного подхода в том, что он опирается не на причины происходящего, а на их следствия. Изменение активности кнопки, блокирование элементов, отображение спиннеров — всё это следствия каких-то процессов. Умение выделить эти процессы и правильно описать в состоянии, один из краеугольных камней хорошей архитектуры.
* Весь процесс условно можно разбить на несколько промежуточных состояний:
  * *filling* – заполнение формы. В этом состоянии всё активно и доступно для редактирования.
  * *processing (или sending)* – отправка формы. Это то самое состояние, когда пользователь ждёт, а приложение пытается предотвратить нежелательные действия, например, клики или изменения данных формы.
  * *processed (или finished)* – состояние, обозначающее что всё завершилось. В нём форма уже не отображается.
  * *failed* – состояние, обозначающее завершение с ошибкой. Например произошел сбой в сети во время загрузки или загруженные данные оказались неверными.
* С точки зрения теории автоматов (а мы имеем дело с автоматным программированием в данном случае), такие состояния называются управляющими. 
* Главное, чтобы все возможные состояния описывали все возможные варианты поведения. Тогда все проверки в выводе сведутся к проверке общего состояния.
* Кроме таких состояний, есть различные данные, сопровождающие наш процесс. Например, *processed* может завершиться с ошибками. В таком случае можно ввести дополнительно массив *errors* (или объект, в зависимости от структуры) с ошибками, который будет заполняться при их наличии. Причём этот же массив с ошибками удобно использовать для валидации формы до отправки на сервер. То есть будучи в состоянии *filling*.
* Глобально, такой подход в разработке, называется программированием с явным выделенным состоянием. Он сводится к тому, что в рамках приложения находятся базовые процессы, от которых зависит всё остальное. Затем эти процессы моделируются с помощью конечных автоматов (FSM). Причём не важно, какие инструменты используются для разработки: чистый DOM, jQuery или любой мощный современный фреймворк. Он применим везде и везде нужен.
* Дополнительные материалы:
  * [Xstate (библиотека для моделирования конечных автоматов)](https://xstate.js.org/docs/)


## Нормализация данных
* Данные приложения почти всегда имеют иерархическую структуру. Иерархическое представление данных хорошо отражает их структуру. Сразу видно, кто к чему относится. Их удобно выводить и вполне удобно изменять. Особенно если вывод на экране совпадает с их структурой, и данные между собой не пересекаются.
* Однако если данные связаны, то иерархическая структура превращается в проблему. Представьте себе, что надо выводить 10 последних комментариев. Как это сделать? Придётся ходить по всем топикам, брать все комментарии, объединять и искать самые свежие. Ещё хуже ситуация становится тогда, когда появляются связи многие-ко-многим. В таком случае непонятно кого куда вкладывать. И всегда будут возникать ситуации что получившаяся структура неудобна.
* Один из выходов из этой ситуации начать дублировать данные. Создавать дополнительные структуры, оптимизированные под конкретные задачи. И хотя, в общем, это не лишено смысла, всё же ручной способ поддерживать эти структуры ничего хорошего не принесёт.
* Другой способ – нормализовать данные, прямо как в реляционных базах данных. Представить их плоскими массивами. Если между данными нет чётких границ и они зависимы друг от друга, то такая структура намного удобнее в работе. Она легко позволяет проводить какие-то общие агрегации и особенные варианты вывода. Немаловажно, что нормализованные данные не дублируются. В хорошо организованном состоянии данные не повторяются более одного раза.
* Подводя итог, можно сказать, что большинство механизмов для хранения состояния на фронтенде, рекомендуют использовать второй способ хранения. Причём не важно, делается это в рамках какого-то фреймворка или нет. Такой подход легче масштабируется и работает неплохо для любых ситуаций. В то время как первый подход создаст много проблем в тот момент, когда структура данных перестанет совпадать с их отображением.


## MVC
* Вышеописанная схема работы с состоянием имеет один существенный недостаток — за вызов отрисовки отвечают обработчики. Теперь представьте, что у нас в приложении десятки обработчиков (что немного) и большое состояние (что типично). В такой ситуации перерисовывать всё на каждое изменение довольно затратная операция. С другой стороны, можно вставить проверку внутри render на каждый кусок состояния и отслеживать, изменился ли он. Такой подход очень быстро станет проблемой сам по себе. Можно легко забыть что-то проверить, можно ошибиться в проверке, можно просто забыть поправить проверку после изменения структуры состояния.
* Существует другой способ выполнить эту задачу. Он основан на такой концепции (говорят шаблон проектирования), как Наблюдатель (Observer). Его идея очень проста: одна часть системы наблюдает за изменением другой части системы. Если наблюдаемый изменился, то наблюдатель может сделать что-то полезное.
* В JS подобный механизм можно реализовать через [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), но это довольно сложно. Более простым решением будет использование готовой библиотеки [on-change](https://github.com/sindresorhus/on-change).
* On-change позволяет "слушать" нужные части состояния и вызывать функции рендеринга при их изменении. То, какие части конкретно слушать и сколько вешать "вотчеров" зависит от задачи. В примитивных ситуациях достаточно одного вотчера на весь стейт (скорее это учебный проект), в реальных же ситуациях вотчеры делают так, чтобы было удобно (в каждой ситуации по-разному).
* Теперь обработчики ничего не знают про рендеринг и отвечают только за взаимодействие с состоянием. В свою очередь рендеринг следит за состоянием и меняет дом только там, где нужно и так, как нужно. Этот способ организации приложения считается уже классическим и носит имя MVC (Model View Controller). Каждое слово обозначает слой приложения со своей зоной ответственности. Model — состояние приложения и бизнес-логика, View — слой, отвечающий за взаимодействие с DOM, Controller — обработчики.
  * Контроллер не может (не может!) менять представление минуя модель. То, что отражено на экране — это отображение состояния приложения и никак иначе.
  * Слой представление не может менять модель во время своей работы.
  * Представление не может притворяться контроллером и выполнять, например, HTTP-запросы.
  * Контроллер что-то делает с данными, на изменение данных срабатывает слой представления и изменяет DOM.
  * Событие => Обновление данных => Отрисовка
* Дополнительные материалы:
  * [Backbone MVC](https://backbonejs.org/#View)


## Состояние форм
* Существует два подхода к обработке состояния формы:
  * Один из них отдаёт контроль состояния самой форме (в реакте - неконтролируемая форма).
  * Другой предполагает его хранение в пользовательском приложении (в реакте - контролируемая форма).
* Неконтролируемые формы, плюсы:
  * Простота. Мало кода, не нужно хранить состояние.
  * Скорость. Браузер делает всю работу сам. Минимум вмешательства со стороны пользовательского кода.
* Неконтролируемые формы, минусы:
  * При таком подходе невозможно реагировать на изменения формы в процессе её заполнения, примеры:
  * Автодополнение. Выпадающие списки зависят от того, что было набрано.
  * Валидация в процессе набора. Часто реализуется в виде красной рамки вокруг поля для ввода.
  * Моментальная фильтрация. Такое часто используется на сервисах бронирования или поиска товаров. Достаточно выбрать какой-то пункт меню, как сразу же меняется выборка.
* Контролируемые формы, плюсы:
  * Позволяет реализовать любую реакцию во время изменения формы до или вместо её отправки.
* Контролируемые формы, минусы:
  * Значительно больше кода при ручной реализации.
  * Они медленнее из-за большего числа действий (и возможно тяжёлой реакции). Но проблема это или нет – зависит от конкретной ситуации.


## Организация текстов интерфейса
* Интерфейс любого сайта включает в себя не только визуальные компоненты, но и текст. Важно, что они не хранятся в базе данных, а зашиты прямо в код в тех местах, где они используются. Эти тексты со временем начинают причинять боль. Они расползаются по всем слоям приложения и засоряют его.
* При правильном подходе, подобные тексты хранятся в одном месте отдельно от кода:
  * Текстами проще управлять, выполнять массовое обновление, отслеживать то, что устарело.
  * Это могут делать не только программисты. Более того, тексты можно выгружать во внешние системы, которые дают возможность работать с ними множеству людей (об этом ниже).
  * Упрощается интернационализация и локализация.
* Даже если ваш сайт не собирается быть мультиязычным, для работы с текстами всё равно используют i18n-библиотеки. i18n – расшифровывается как интернационализация (internationalization). Мультиязычность – это приятное дополнение, которое можно задействовать, если вдруг понадобится.
* В мире JS наиболее популярной библиотекой для работы с текстами стала [i18next](https://www.i18next.com/).
* Типичная ошибка при работе с текстами – хранить их прямо в состоянии. Он не сочетается с переключением языков. Представьте, что пользователь поменял язык интерфейса, а в состоянии в это время записаны тексты. Появляется проблема – как изменить тексты на правильный язык? В общем случае никак, потому что в строке текста нет информации о том, что это было.
* Любые тексты, которые выводятся в зависимости от действий пользователя, не должны храниться в состоянии приложения. Эти тексты должны зависеть от состояния процессов.


## Инициализация приложения
* Работу любого приложения можно условно разделить на три стадии, через которые оно проходит в процессе жизни:
  * Инициализацию
  * Исполнение
  * Завершение
* Что входит в инициализацию? Всё, что нужно сделать ровно один раз для последующего использования в приложении:
  * Создание начального состояния
  * Подключение вебсокетов
  * Настройка i18next
  * Загрузка и запуск фреймворка, если он есть
  * Настройка различных библиотек: http-клиенты, работа с датами и так далее
  * Этот список далеко не полный, в каждой конкретной ситуации в инициализацию попадает что-то свое.
* На практике процесс инициализации организуется так: создается функция, внутри которой выполняется вся необходимая настройка. Для удобства сделать это можно в файле init.js.
* Запуск этой функции происходит уже в другом месте, например, в файле index.js, который является точкой входа в приложения.
* Почему разделение именно такое? Во фронтенде приложение, как правило, глобально. То есть оно одно на всю страницу, грузится ровно один раз и один раз запускается и управляет всем происходящим так, как будто вокруг больше ничего нет (других приложений о которых нужно думать). Но так бывает не всегда. Например виджеты могут появляться на одной странице более одного раза, а значит каждый виджет должен быть вещью "в себе". То есть инициализация такого виджета работает в своем собственном окружении со своими собственными объектами и не меняет ничего вне (глобальные объекты). Иначе возникнут конфликты и один виджет будет мешать другому.
* С другой стороны, в тестировании каждый тест строится так, что он не зависит от других тестов, то есть каждый тест работает так, как будто других тестов не существует. Такое поведение требует инициализации приложения для каждого теста "с нуля". Только в этом случае можно гарантировать, что изменения состояния приложения, сделанные в одном тесте не повлияют на другие тесты.
* Дополнительные материалы:
  * [Состояние на уровне модулей](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)
  * [Скрипты, модули и библиотеки](https://ru.hexlet.io/blog/posts/skripty-moduli-i-biblioteki)
