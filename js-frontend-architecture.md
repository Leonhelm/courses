# JS: Архитектура фронтенда [[hexlet](https://ru.hexlet.io/courses/js-frontend-architecture)]


## Состояние приложения
* Событийная архитектура и DOM без должного внимания порождают запутанный код буквально сразу
* Необходимость базы данных довольно очевидна и понятна для всех, но то же самое не очевидно во фронтенде. DOM позволяет хранить состояние внутри себя и, более того, провоцирует так делать. Главная проблема такого подхода в отсутствии единого источника правды.
* Первый шаг в построении правильной архитектуры состоит в выделении данных которыми манипулирует приложение из DOM в отдельную переменную на уровне приложения. Это позволит отделить работу с данными от их отображения.
* Дополнительные материалы:
  * [Скрипты, модули и библиотеки](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/state/exercise_unit)
  * [Совершенный код: состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)


## Комплексное состояние
* Cостояние — это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере
* В приложениях далеко не все данные могут изменяться с течением времени. К таким данным может относиться конфигурация, например таймауты, различные ключи доступа или настройки библиотек. Такие данные (можно сказать что они статические) в состоянии не хранят. Достаточно иметь отдельные константы созданные прямо по месту использования, либо импортируемые из специального модуля с настройками
* Само состояние лучше всего организовывать в виде одной константы содержащей объект. За таким объектом гораздо проще следить, чем за набором разных констант или переменных
* Частая ошибка при формировании состояния, привязка структуры состояния к визуальному оформлению. Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придётся править
* Состояние приложения это данные, а не их отображение. Поэтому хранение DOM-элементов в состоянии считается плохой практикой. Фактически это возврат к структуре до введения состояния, когда данные хранились внутри представления
* Дополнительные материалы:
  * [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)


## Отрисовка (рендеринг) состояния
* Обновление внешнего вида на основе состояния, обычно, выносят в отдельный слой, который называется представлением (View). В простейшем случае представлением является функция, которая принимает на вход состояние, анализирует его и производит необходимые изменения в DOM.
* С ростом приложения увеличивается и количество обработчиков. Каждый из них может приводить к изменению только части страницы. 
* Наиболее простым решением будет привязка таких функций к элементам состояния. Предположим что у нас есть страница управления списком уроков в курсе.
* Для отрисовки этого списка подойдет одна функция `renderLessons()`, которая будет вызываться во всех обработчиках изменяющих этот список: удаляющих или добавляющих элементы.
* Что происходит внутри этой функции? Кажется что внутри функции рендеринга нужно определять что произошло и, затем, менять необходимую часть дома, например, удалить какой-то элемент, которого больше нет. В реальности это очень затратный подход, его сложно программировать, так как появляется большое количество условных конструкций. Намного проще выполнять полную перерисовку в любой ситуации. Тогда код останется максимально простым.
* Теперь наше приложение разделено на три независимых части: состояние (данные приложения), обработчики и рендеринг.
* Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют:
  * Состояние не знает ничего про остальные части системы — оно ядро.
  * Рендеринг пользуется состоянием для отрисовки и добавляет новые обработчики в DOM
  * Обработчики знают про состояние, так как обновляют его и инициируют рендеринг


## Состояние отображения (UI State)
* Изменение состояния фронтенд-приложения не всегда означает изменение данных, с которыми работает приложение. У данных может быть состояние, которое влияет только на внешний вид. На сервере, в базе данных, такое состояние отсутствует.
* UI-состояние хранят отдельно от самих данных.


## Процессы и автоматы, их описывающие
* В идеале, любые изменения в интерфейсе являются следствием изменения данных, то есть состояния приложения.
* Проблема флагоориентированного подхода в том, что он опирается не на причины происходящего, а на их следствия. Изменение активности кнопки, блокирование элементов, отображение спиннеров — всё это следствия каких-то процессов. Умение выделить эти процессы и правильно описать в состоянии, один из краеугольных камней хорошей архитектуры.
* Весь процесс условно можно разбить на несколько промежуточных состояний:
  * *filling* – заполнение формы. В этом состоянии всё активно и доступно для редактирования.
  * *processing (или sending)* – отправка формы. Это то самое состояние, когда пользователь ждёт, а приложение пытается предотвратить нежелательные действия, например, клики или изменения данных формы.
  * *processed (или finished)* – состояние, обозначающее что всё завершилось. В нём форма уже не отображается.
  * *failed* – состояние, обозначающее завершение с ошибкой. Например произошел сбой в сети во время загрузки или загруженные данные оказались неверными.
* С точки зрения теории автоматов (а мы имеем дело с автоматным программированием в данном случае), такие состояния называются управляющими. 
* Главное, чтобы все возможные состояния описывали все возможные варианты поведения. Тогда все проверки в выводе сведутся к проверке общего состояния.
* Кроме таких состояний, есть различные данные, сопровождающие наш процесс. Например, *processed* может завершиться с ошибками. В таком случае можно ввести дополнительно массив *errors* (или объект, в зависимости от структуры) с ошибками, который будет заполняться при их наличии. Причём этот же массив с ошибками удобно использовать для валидации формы до отправки на сервер. То есть будучи в состоянии *filling*.
* Глобально, такой подход в разработке, называется программированием с явным выделенным состоянием. Он сводится к тому, что в рамках приложения находятся базовые процессы, от которых зависит всё остальное. Затем эти процессы моделируются с помощью конечных автоматов (FSM). Причём не важно, какие инструменты используются для разработки: чистый DOM, jQuery или любой мощный современный фреймворк. Он применим везде и везде нужен.
* Дополнительные материалы:
  * [Xstate (библиотека для моделирования конечных автоматов)](https://xstate.js.org/docs/)


## Нормализация данных
* Данные приложения почти всегда имеют иерархическую структуру. Иерархическое представление данных хорошо отражает их структуру. Сразу видно, кто к чему относится. Их удобно выводить и вполне удобно изменять. Особенно если вывод на экране совпадает с их структурой, и данные между собой не пересекаются.
* Однако если данные связаны, то иерархическая структура превращается в проблему. Представьте себе, что надо выводить 10 последних комментариев. Как это сделать? Придётся ходить по всем топикам, брать все комментарии, объединять и искать самые свежие. Ещё хуже ситуация становится тогда, когда появляются связи многие-ко-многим. В таком случае непонятно кого куда вкладывать. И всегда будут возникать ситуации что получившаяся структура неудобна.
* Один из выходов из этой ситуации начать дублировать данные. Создавать дополнительные структуры, оптимизированные под конкретные задачи. И хотя, в общем, это не лишено смысла, всё же ручной способ поддерживать эти структуры ничего хорошего не принесёт.
* Другой способ – нормализовать данные, прямо как в реляционных базах данных. Представить их плоскими массивами. Если между данными нет чётких границ и они зависимы друг от друга, то такая структура намного удобнее в работе. Она легко позволяет проводить какие-то общие агрегации и особенные варианты вывода. Немаловажно, что нормализованные данные не дублируются. В хорошо организованном состоянии данные не повторяются более одного раза.
* Подводя итог, можно сказать, что большинство механизмов для хранения состояния на фронтенде, рекомендуют использовать второй способ хранения. Причём не важно, делается это в рамках какого-то фреймворка или нет. Такой подход легче масштабируется и работает неплохо для любых ситуаций. В то время как первый подход создаст много проблем в тот момент, когда структура данных перестанет совпадать с их отображением.


## MVC
* Вышеописанная схема работы с состоянием имеет один существенный недостаток — за вызов отрисовки отвечают обработчики. Теперь представьте, что у нас в приложении десятки обработчиков (что немного) и большое состояние (что типично). В такой ситуации перерисовывать всё на каждое изменение довольно затратная операция. С другой стороны, можно вставить проверку внутри render на каждый кусок состояния и отслеживать, изменился ли он. Такой подход очень быстро станет проблемой сам по себе. Можно легко забыть что-то проверить, можно ошибиться в проверке, можно просто забыть поправить проверку после изменения структуры состояния.
* Существует другой способ выполнить эту задачу. Он основан на такой концепции (говорят шаблон проектирования), как Наблюдатель (Observer). Его идея очень проста: одна часть системы наблюдает за изменением другой части системы. Если наблюдаемый изменился, то наблюдатель может сделать что-то полезное.
* В JS подобный механизм можно реализовать через [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), но это довольно сложно. Более простым решением будет использование готовой библиотеки [on-change](https://github.com/sindresorhus/on-change).
* On-change позволяет "слушать" нужные части состояния и вызывать функции рендеринга при их изменении. То, какие части конкретно слушать и сколько вешать "вотчеров" зависит от задачи. В примитивных ситуациях достаточно одного вотчера на весь стейт (скорее это учебный проект), в реальных же ситуациях вотчеры делают так, чтобы было удобно (в каждой ситуации по-разному).
* Теперь обработчики ничего не знают про рендеринг и отвечают только за взаимодействие с состоянием. В свою очередь рендеринг следит за состоянием и меняет дом только там, где нужно и так, как нужно. Этот способ организации приложения считается уже классическим и носит имя MVC (Model View Controller). Каждое слово обозначает слой приложения со своей зоной ответственности. Model — состояние приложения и бизнес-логика, View — слой, отвечающий за взаимодействие с DOM, Controller — обработчики.
  * Контроллер не может (не может!) менять представление минуя модель. То, что отражено на экране — это отображение состояния приложения и никак иначе.
  * Слой представление не может менять модель во время своей работы.
  * Представление не может притворяться контроллером и выполнять, например, HTTP-запросы.
  * Контроллер что-то делает с данными, на изменение данных срабатывает слой представления и изменяет DOM.
  * Событие => Обновление данных => Отрисовка
* Дополнительные материалы:
  * [Backbone MVC](https://backbonejs.org/#View)


## 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
