# Безопасность web-приложений [CyberED]

## Введение в информационную безопасность и безопасность веб-приложений

### Certificates

Offensive Security Certified Professional (OSCP)
Certified Ethical Hacker (CEH)

### Work experience

Independet Security Researcher| HackerU | Kaspersky Lab

## Терминология

Краткая памятка:

 - То, что может сделать с информацией атакующий, называется **угрозой (threat)**;
 - То, благодаря чему он может это сделать, называется **уязвимостью (vulnerability)**, обусловленной **недостатком (weakness)**
 - То, как он может это сделать, называется **атакой (attack)**
 - То, с какой вероятностью злоумышленник это сделает и какие последствия это может повлечь, называется **риском (risk)**
 - То, что не позволяет атакующему провести атаку, обеспечивает **защищенность (security)**
 - То, что минимизирует риск, обеспечивает **безопасность (safety)**


## Информационная безопасность

- Защита конфиденциальности, целостности и доступности информации, а также сюда могут быть включены другие свойства, такие как подлинность, подотчетность, неотказуемость (англ. non-repudiation) и достоверность.
- Защита информации и информационных систем от неавторизованного доступа, использования, раскрытия, искажения, изменения или уничтожения в целях обеспечения конфиденциальности, целостности и доступности.
- Обеспечение защиты информации на предприятии от раскрытия неавторизованным пользователям (конфиденциальность), противоправного изменения (целостность) и недоступности, когда она необходима (доступность).
- Процесс защиты интеллектуальной собственности организации.
- Одна из дисциплин управления рисками, чьей задачей является управление стоимостью информационных рисков для бизнеса.
- Обоснованная уверенность в том, что информационные риски уравновешены соответствующими мерами контроля и управления.
- Защита информации, минимизирующая риск разглашения информации неавторизованным лицам.
- Процесс баланса между возникающими, воздействующими угрозами и успешностью противодействия этим угрозам со стороны органов государственной власти, отвечающих за безопасность государства.
- Мультидисциплинарная область исследований и профессиональной деятельности, которая сосредоточена на развитии и внедрении всевозможных механизмов безопасности (технических, организационных, человекоориентированных, юридических) с целью предохранения информации от угроз повсюду, где бы она ни находилась (как внутри периметра организации, так и за его пределами) и, соответственно, информационных систем, в которых информация создаётся, обрабатывается, хранится, передаётся и уничтожается. Перечень целей безопасности может включать конфиденциальность, целостность, доступность, неприкосновенность частной жизни, подлинность и достоверность, неотказуемость, подотчетность и проверяемость.



## Веб-приложения и уязвимости веб-приложений

Веб-сервер - сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.


Веб-сервер отвечает за предварительную обработку поступающих запросов. Он управляет сетевыми соединениями, может реализовывать кеширование и передачу запросов другим хостам.
Также он передает по определенному интерфейсу запросы программному коду на различных языках программирования.


Веб-приложение - клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети.

Использование паттернов:

- Model-View-Controller
- Model-View-Presenter
- Model-View-ViewModel
- ...

Использование фреймворков:

- Java - Spring, JSF, Struts, ...
- PHP - Laravel, Symfony, ZEND, Yii, ...
- Ruby - Ruby on rails, ...
- Python - Flask, Django, ...
- JS (Node.js) - Express.JS, Meteor.JS, ...
- C# (ASP.NET) - (ASP.NET Web Forms, ASP.NET MVC , ASP.NET Web Pages, ASP.NET Web API , ASP.NET WebHooks, SignalR), ...

Компоненты современных веб-приложений:

| Клиентская часть | Серверная часть | Хранение данных | Другие компоненты |
| ---------------- | --------------- | --------------- | ----------------- |
|   Electron       | Nginx           | Files System        | Reverse-Proxy |
|   JavaScript     | Apache          | MySQL               | Load Balancer |
|   TypeScript     | Apache Tomcat   | PostgreSQL          | Proxy Server |
|   ReactJS        | Microsoft IIS   | mongoDB             | Cache Server |
|   Redux          | Gunicorn        | Oracle              | WebSocket |
|   AngularJS      | uWSGI           | IBM DB 2            | Web Application Firewall |
|   Vue.js         | Java            | Microsoft SQL Server |  |
|   jQuery         | Python          | SQLite              |  |
|                  | PHP             | Redis               |  |
|                  | NodeJs          | Memcached           |  |
|                  | C#              | Neo4j               |  |
|                  | Go              | Tarantool           |  |
|                  | RubyOnRails     | XML                 |  |
|                  |                 | YAML                |  |


### Угрозы веб-приложений

Злоумышленники могут нанести ущерб вашему бизнесу или организации, используя ваше приложение. Подобные способы использования приложения представляют собой угрозы, которые могут (или не могут) быть достаточно серьезными, чтобы обращать на них внимание.

Списки уязвимостей и угроз приложений:

- Кратко - https://owasp.org/www-project-top-ten/ ([PDF](https://wiki.owasp.org/images/9/96/OWASP_Top_10-2017-ru.pdf))
- Развернуто - https://cwe.mitre.org/data/definitions/699.html

## Стандарты в области безопасности разработки веб-приложений

### Топ-10 OWASP

Основной целью Топ-10 OWASP является ознакомление разработчиков, проектировщиков, архитекторов, менеджеров и организаций в целом с рисками, связанными с наиболее распространенными и существенными недостатками в безопасности веб-приложений. Топ-10 также предлагает базовые способы защиты от подобных рисков и руководства по дальнейшим действиям.

### Более фундаментальные стандарты и методологии

- [Стандарт подтверждения безопасности приложений OWASP (ASVS)](https://www.owasp.org/index.php/Category:OWASP_Application_Security_Verification_Standard_Project)
- [Приложение по безопасности к Контракту на разработку ПО от OWASP. ](https://owasp.org/www-community/OWASP_Secure_Software_Contract_Annex)
- [Памятки OWASP](https://cheatsheetseries.owasp.org/index.html)
- [OWASP RRM](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology)
- [OWASP Web Security Testing Guide](https://github.com/OWASP/wstg)
- [OWASP Developers Guide](https://github.com/OWASP/DevGuide)
- [Microsoft SDL](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc307891(v=msdn.10))
- [BSIMM — Building Security In Maturity Model](https://www.bsimm.com/)
- [Эксплуатации уязвимостей](https://github.com/swisskyrepo/PayloadsAllTheThings)
- [Мониторинг актуальных уязвимостей](https://cvetrends.com/)

## Безопасная разработка

**Application Security** — это раздел безопасности, который отвечает за безопасность приложений.

**Security Development Lifecycle** (SDL, жизненный цикл безопасной разработки) — концепция разработки, заключающаяся в формировании требований к приложению, безопасном программировании, тестировании, сертификации, эксплуатации и обновлении. SDL — это процесс, который позволяет поддерживать необходимый уровень безопасности системы на этапе разработки, а затем на протяжении всего срока эксплуатации. Эта концепция фокусируется на обеспечении безопасности разрабатываемого приложения, идентификации рисков и управлении ими.

![SSDLC](https://i.imgur.com/e0DCtky.png)


## Инструменты и методологии поиска уязвимостей веб-приложений (DAST, SAST, SCA)

### Dynamic Application Security Testing (DAST)

Dynamic Application Security Testing - это процесс тестирования приложения или программного продукта в рабочем состоянии. Такой вид тестирования полезен для обеспечения защищенности актуальной версии продукта и для постоянной проверки состояния защищенности системы.

Задачи:

- Поиск незадекларированных возможностей
- Поиск неконтролируемых утечек ресурсов
- Поиск уязвимостей конфигурации развернутого приложения
- Поиск аномалий поведения при взаимодействии с входными точками приложения

### Static Application Security Testing (SAST)

Инструменты анализа исходного кода, также известные как Static Application Security Testing (SAST) Tools, предназначены для анализа исходного кода или скомпилированных версий кода, чтобы помочь найти дефекты безопасности.

Задачи:

- Поиск скрытых уязвимостей
- Поиск логических ошибок
- Поиск ошибки архитектуры
- Поиск дефетов реализации
- Поиск "Мертвого" кода
- Поиск "Закладок"
- Поддержка уровня качества кода и отклонений от стандартов

### Software Composition Analysis (SCA)

Программные решения типа Software Composition Analysis (SCA), предназначены для автоматизированного обнаружения рисков и устранения уязвимостей в коде, контроля использования внешних (готовых) библиотек.

Задачи:

- Инвентаризация всех открытых исходных кодов (OSS) и запатентованных компонентов, используемых на предприятии.
- Определение компонентов с уязвимостями безопасности, известными как Common Vulnerabilities and Exposures (CVE) (Общие уязвимости и воздействия)
- Идентифицировать компоненты с лицензиями, не соответствующими предполагаемому использованию компанией программного обеспечения.
- Обнаружение устаревших компонентов, которые больше не поддерживаются, чтобы их можно было заменить текущими версиями.
- Эффективное и быстрое распространение информации о выявленных рисках среди членов команды, которые могут принять меры по их устранению.
- Отслеживать смягчение выявленных рисков, связанных с безопасностью и лицензированием.
- Обеспечить механизм для непрерывного выполнения SCA

## Дополнительные материалы


Список популярных каналов и чатов на темы связанные с информационной безопасностью: https://t.me/YAH_Channel/191




## Уязвимости инъекции

Уязвимости, связанные, например, с внедрением SQL, NoSQL, OS и LDAP, возникают, когда непроверенные данные отправляются интерпретатору в составе команды или запроса. Вредоносные данные могут заставить интерпретатор выполнить непредусмотренные команды или обратиться к данным без прохождения соответствующей авторизации. 

Внедрения особенно распространены в старом коде. Уязвимости часто встречаются в SQL- LDAP-, XPathили NoSQL-запросах, системных командах, XMLобработчиках, SMTP-заголовках, языках выражений и ORM-запросах. Внедрения легко обнаружить при анализе кода. Сканеры и фаззеры могут помочь злоумышленникам найти подобные уязвимости.

## Инъекции команд ОС

### Что такое инъекции команд?

Инъекция команд ОС (также известная как shell инъекция) является уязвимостью веб-приложений, которая позволяет злоумышленнику выполнять произвольные команды операционной системы (ОС) на сервере, на котором запущено приложение, и, как правило, дает возможность полностью скомпрометировать приложение и все его данные. Очень часто злоумышленник может использовать уязвимость внедрения команд ОС для компрометации других частей инфраструктуры, используя доверительные отношения для перенаправления атаки на другие системы в организации.

### Как возникают инъекции команд?

Пример уязвимости инъекции команд:

```php=
$command = 'convert -pointsize 72 label:Hello  ' . $_FILES['userfile']['name'];
system($command);
```

Пример эксплуатации для уязвимости выше:

```http=
------WebKitFormBoundaryePkpFF7tjBAqx29L
Content-Disposition: form-data; name="userfile"; filename="check | ls -la;"
Content-Type: application/x-object

... contents of file goes here ...
```

### Как предотвратить инъекции команд?

На сегодняшний день наиболее эффективным способом предотвращения уязвимостей инъекции команд ОС является никогда не вызывать команды ОС из кода прикладного уровня. Практически в каждом случае существуют альтернативные способы реализации требуемой функциональности с использованием более безопасных платформенных API.

1. **Избегать прямого выполнения команд ОС**. Для огромного количества различных функций реализованы библиотеки.
2. Использовать функции языка для **вызова других программ без обращения к оболочке ОС** (proc_open в PHP)
3. **Не передавать пользовательский ввод** в командную оболочку.
4. В крайнем случае **используйте специальные функции для экранирования** (escapeshellargs в PHP)

Если считается неизбежным вызывать команды ОС с пользовательским вводом, то должна быть выполнена серьезная проверка вводимых данных:

1. Соответствие типу данных
2. Корректность формата
3. Регулярные выражения
4. Разрешенный набор символов

## Инъекции управляющих конструкций SQL

### Что такое SQL инъекция?

SQL-инъекция - это уязвимость веб-приложений, позволяющая злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, она позволяет злоумышленнику просматривать данные, которые он, как правило, не может получить. Сюда могут входить данные, принадлежащие другим пользователям, или любые другие данные, к которым само приложение может получить доступ. Во многих случаях злоумышленник может изменять или удалять эти данные, вызывая постоянные изменения содержимого или поведения приложения.

В некоторых ситуациях злоумышленник может эскалировать атаку SQL-инъекции, чтобы скомпрометировать сервер или другую внутреннюю инфраструктуру, или выполнить атаку типа "отказа в обслуживании".

### Какой ущерб несут уязвимости к инъекции SQL?

Успешная атака SQL-инъекции может привести к несанкционированному доступу к конфиденциальным данным, таким как пароли, данные кредитной карты или личная информация пользователя. Многие громкие утечки данных в последние годы стали результатом атак SQL-инъекции, что привело к репутационному ущербу и штрафам со стороны регулирующих органов. В некоторых случаях злоумышленник может получить постоянный черный ход в системы организации, что приводит к долгосрочному закреплению злоумышленника в инфраструктуре, которое может оставаться незамеченным длительный период времени.

В частности, уязвимости SQL-инъекций могут приводить к:

- Извлечению данных и возможности исследования базы данных
- Модификации информации в базе данных (удалению, добавлению, изменению)
- Обходу логики
- Обходу механизмов авторизации и аутентификации
- Чтению файлов ОС
- Выполнению команд ОС
- Отказу в обслуживании

### Примеры SQL инъекций

**Сценарий №1** Приложение использует недоверенные данные при создании следующего уязвимого SQL-вызова:

```sql=
String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";
```

**Сценарий №2** Безоговорочное доверие приложений к фреймворкам может привести к появлению уязвимых запросов (например, в языке запросов HQL):

```sql=
Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");
```

В обоих случаях злоумышленник изменяет в своем браузере значение параметра "id" для отправки `' or '1'='1`. 

Например:
`http://example.com/app/accountView?id='+or+'1'='1`

Изменение обоих запросов позволяет получить все записи из таблицы учетных данных. Более серьезные атаки позволяют изменить или удалить.

**Сценарий №3** Использование фреймворков, кажущееся безопасным, может быть обманчивым (Пример использования фреймворка Ruby On Rails и Active Records):

```sql=
User.order("#{params[:sortby]} ASC")
```

Кажущийся безопасным вызов `.order()` на самом деле не экранирует управляющих конструкций получаемых от приложения, что приводит к возможности проведения атак на базу данных, через такой вектор как:
```sql=
(CASE SUBSTR(password, 1, 1) WHEN 's' THEN 0 else 1 END)
```

#### О техниках атак

Существует широкий спектр уязвимостей, атак и методов SQL инъекции, которые возникают в различных ситуациях. К числу наиболее распространенных примеров SQL-инъекций относятся:

- SQL Injection Bypass
- Stacked queries
- Union-based
- Error-based
- Boolean blind
- Time-base
- Out of band

### Как предотвращать SQL инъекции?

Большинство случаев SQL-инъекции можно предотвратить, используя параметризованные запросы (также известные как "prepared statements") вместо конкатенации строк внутри запроса.

Также, от SQL-инъекций спасает концепция ORM (Object-Relational Mapping), но не следует ей слепо доверять.


## Дополнительные материалы
:::success
- [PayloadsAllTheThings - SQL injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)
- [PayloadsAllTheThings - NoSQL injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection)
- [OWASP NoSQL injection slides](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf)
- [PortSwigger - SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
- [SQLMap - Инструмент автоматизации](https://xakep.ru/2011/12/06/57950/)
:::


## Упражнения

### Упражнение 1

Инъекция команды ОС, простой случай - https://portswigger.net/web-security/os-command-injection/lab-simple (Сложность: Низкая)

### Упражнение 2

UNION-based атака SQL инъекции, на извлечение данных из других таблиц - https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-data-from-other-tables (Сложность: Низкая)

## Что такое внедрение шаблона на стороне сервера?

Инъекция шаблонов на стороне сервера - это атака, при которой злоумышленник может использовать собственный синтаксис шаблона для введения вредоносной полезной нагрузки в шаблон, который затем выполняется на стороне сервера.

Движки шаблонов предназначены для генерации веб-страниц путем объединения фиксированных шаблонов с изменчивыми данными. Атаки с инъекцией шаблонов на стороне сервера могут происходить, когда вводимые пользователем данные не передаются в виде данных, а непосредственно вставляются в шаблон. Это позволяет злоумышленникам вводить произвольные директивы шаблонов для манипулирования движком шаблонов, часто позволяя им получить полный контроль над сервером.

## Какой ущерб несут уязвимости к инъекции шаблонов?

Уязвимости инъекции шаблонов на стороне сервера могут подвергать веб-сайты различным атакам в зависимости от движка шаблонов и того, как именно приложение его использует. В некоторых редких случаях эти уязвимости не представляют реального риска для безопасности. Однако, в большинстве случаев, воздействие инъекции шаблона на стороне сервера может быть катастрофическим.

В самом крайнем случае злоумышленник потенциально может добиться удаленного выполнения кода, получив полный контроль над внутренним сервером и используя его для других атак на внутреннюю инфраструктуру.

Даже в тех случаях, когда полное удаленное выполнение кода невозможно, злоумышленник часто все равно может использовать внедрение шаблонов на стороне сервера в качестве основы для множества других атак, потенциально получая доступ на чтение к конфиденциальным данным и произвольным файлам на сервере.

## Как появляются уязвимости инъекции шаблонов?

Рассмотрим несколько примеров кода:

Пример НЕ уязвимый к SSTI:

```php=
<?php

require_once('lib/Twig/Autoloader.php');
Twig_Autoloader::register();

$loader = new Twig_Loader_Filesystem('views');

$twig = new Twig_Environment($loader, array(
  'cache' => 'cache',
));

echo $twig->render('index.html', array('name' => '', 'title' => 'Startpage'));

?>
```

Пример уязвимый к SSTI:

```php=
<?php

require_once('lib/Twig/Autoloader.php');
Twig_Autoloader::register();

$twig = new \Twig_Environment(new \Twig_Loader_String());

echo $twig->render("Error message: ".$_GET['error']);

?>
```

## Проведение атаки инъекции шаблонов

### Сценарий №1 Пример для кода шаблонизатора PHP Twig

Код: 
```php=
echo $twig->render("Error message: ".$_GET['error']);
```

Эксплоит:

```php=
{{['cat\x20/etc/passwd']|filter('system')}}
```

### Сценарий №2 Пример для кода шаблонизатора ASP.NET Razor

Код:
```c#=
[HttpPost]
[ValidateInput(false)]
public ActionResult Index(string razorTpl)
{
	ViewBag.RenderedTemplate = Razor.Parse(razorTpl);
	ViewBag.Template = razorTpl;
	return View();
}
```

Эксплоит:
```=
@{
  // C# code
}
```

### Сценарий №3 Пример для кода шаблонизатора Java Velocity

Код:
```java=
// Set up the context data
VelocityContext context = new VelocityContext();
context.put( "name", user.name );

// Load the template
String template = getUserTemplateFromRequestBody(request);
RuntimeServices runtimeServices = RuntimeSingleton.getRuntimeServices();
StringReader reader = new StringReader(template);
SimpleNode node = runtimeServices.parse(reader, "myTemplate");
template = new Template();
template.setRuntimeServices(runtimeServices);
template.setData(node);
template.initDocument();

// Render the template with the context data
StringWriter sw = new StringWriter();
template.merge( context, sw );
```

Эксплоит:
```=
$name.getClass().forName("java.lang.Runtime").getRuntime().exec(<COMMAND>)
```

## Как защищаться от инъекции шаблонов?

Лучший способ предотвратить инъекцию шаблонов на стороне сервера - **не позволять никаким пользователям изменять или отправлять новые шаблоны**. Однако иногда это неизбежно из-за требований бизнеса.

Один из простейших способов избежать внедрения уязвимостей инъектирования шаблонов на стороне сервера - **всегда использовать "logic-less" шаблонный движок**, такой как Mustache, если в этом нет абсолютной необходимости. Максимально возможное отделение логики от представления может значительно уменьшить вашу подверженность наиболее опасным атакам на основе шаблонов.

Другой мерой является **выполнение пользовательских шаблонов только в песочнице**, где потенциально опасные модули и функции были полностью удалены. К сожалению, недоверенный код в песочнице по своей природе сложен и склонен к обходу.

Наконец, еще одним дополнительным подходом является признание того, что произвольное выполнение кода практически неизбежно, и **применение собственной "песочницы" путем развертывания среды шаблонов**, например, в изолированном контейнере Docker.

## Дополнительные материалы
:::success
- [PayloadsAllTheThings - Templates Injections](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)
- [TPLMap: инструмент автоматизации](https://github.com/epinna/tplmap)
:::

## Упражнения

### Упражнение 1

Основы инъеции шаблонов на стороне сервера - https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic (Сложность: низкая)

### Упражнение 2

Основы инъекции шаблонов на стороне сервера (контекст кода) - https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic-code-context (Сложность: низкая)

GraphQL инъекции

Содержание:

- Что такое GraphQL
- Какие могут быть проблемы?
- Известные отчеты
- Упражнение


## Что такое GraphQL

GraphQL это язык запросов, который позволяет описать типы данных и дать возможность их собирать с помощью описанного синтаксиса.

С помощью GraphQL можно объединить разнотипные источники данных. Чаще всего используется этот язык для того чтобы получать данные от сервера.

Обычно GraphQL API состоит из:

1.  schema - описание данных
2.  queries - запрос данных
3.  resolvers - кусок кода, который описывает алгоритм преобразования данных

Проще всего рассматривать через официальный [курс](https://graphql.org/learn/).

## Какие могут быть проблемы?

- может быть реализован SSRF, если не проверяются параметры резолверов
- нарушение разграничения доступа - по-умолчанию его нет и разработчики должны самостоятельно его имплементировать
- DDOS - GraphQL не ограничивает количество вложенных элементов в запросе
- может быть использован для атак на обслуживаемые ресурсы: sql injection, Nosql injectio, Os Command Injection и т.д.
- доступных механизм интроспекции, позволяет получить данные о структуре хранилищ.

Пример запроса интроспекции:

```
{ 
 __schema { 
  types { 
   name 
   } 
  } 
}
```

Пример атак sql и nosql:

```
mutation { 
    login(input: {
        user: "admin", 
        password: "password' or 1=1 -- -"
    }) { 
        success
    } 
}

mutation {
    users(search: "{password: { $regex: \".*\"}, name:Admin }") {
        id
        name
        password
    }
}
```


## Известные отчеты

- https://gitlab.com/gitlab-org/gitlab/-/issues/215703
- https://hackerone.com/reports/1122408
- https://hackerone.com/reports/342978
- https://hackerone.com/reports/380317

## Упражнение

https://www.root-me.org/en/Challenges/Web-Server/GraphQL

Полезный ресурс для работы с GraphQL - https://apis.guru/graphql-voyager/


## Что такое Аутентификация?

Аутентификация - это процесс проверки личности конкретного пользователя или клиента. Другими словами, он включает в себя **проверку того, что они действительно те, за кого себя выдают**. По крайней мере, частично, веб-сайты открыты для всех, кто подключен к Интернету. Поэтому надежные механизмы аутентификации являются неотъемлемым аспектом веб-безопасности.

Классифицировать различные типы проверки подлинности можно по трем факторам проверки подлинности:

1. **Знание**, например, пароль или ответ на вопрос безопасности. Их иногда называют "факторами знаний".
2. **Обладание**, то есть физический объект, такой как мобильный телефон или маркер безопасности. Их иногда называют "факторами владения".
3. **Биометрия**, например, биометрия или модели поведения. Их иногда называют "факторами согласованности".

Механизмы аутентификации полагаются на целый ряд технологий для проверки одного или нескольких из этих факторов.

## Разница между аутентификацией, авторизацией и идентификацией?

Идентификация позволяет нам определить что за объект перед нами, за счет присвоения субъектам и объектам идентификатора.

Аутентификация - это процесс проверки того, действительно ли пользователь является тем, за кого он себя выдает, в то время как авторизация включает в себя проверку того, разрешено ли пользователю что-либо делать.

## Как возникают уязвимости аутентификации?

В широком смысле, большинство уязвимостей в механизмах аутентификации возникает одним из двух способов:

1. Механизмы аутентификации уязвимы, так как они **не могут адекватно защитить от атак с применением методов "грубой силы"**.
2. **Логические ошибки или плохой код** в реализации позволяют злоумышленнику полностью обойти механизмы аутентификации. 


## Какой ущерб несут уязвимости аутентификации?

Влияние уязвимостей аутентификации может быть очень серьезным. После того, как злоумышленник либо обошел аутентификацию, либо взломал учетную запись другого пользователя, он получает **доступ ко всем данным и функциональности, которыми обладает скомпрометированная учетная запись**. Если им удается скомпрометировать высокопривилегированную учетную запись, например, системного администратора, они могут получить полный контроль над всем приложением и потенциально получить доступ к внутренней инфраструктуре.

Даже компрометация низкопривилегированной учетной записи все равно может предоставить злоумышленнику доступ к данным, которые в противном случае не должны были бы быть у него, например, к коммерческой коммерческой информации. Даже если учетная запись не имеет доступа к конфиденциальным данным, она все равно может позволить злоумышленнику получить доступ к дополнительным страницам, которые обеспечивают дополнительную поверхность атаки. Часто некоторые атаки с высокой степенью вероятности будут невозможны с общедоступных страниц, но они могут быть возможны и с приватной страницы.

## Уязвимости в механизмах аутентификации

Система аутентификации веб-сайта, как правило, состоит из нескольких различных механизмов, в которых могут возникать уязвимости. Некоторые уязвимости широко применимы во всех этих контекстах, в то время как другие более специфичны с точки зрения предоставляемой функциональности.

Мы рассмотрим более подробно некоторые из наиболее распространенных уязвимостей в следующих областях:

- Уязвимости при входе в на основе пароля
- Уязвимости при многофакторной аутентификации
- Уязвимости в других механизмах аутентификации

### Уязвимости в Password-based аутентификации

Для веб-сайтов, использующих процесс входа на основе пароля, пользователи либо сами регистрируются для получения учетной записи, либо администратор присваивает им учетную запись. Эта учетная запись связана с уникальным именем пользователя и секретным паролем, который пользователь вводит в форме входа для аутентификации.

В этом сценарии, **сам факт, что они знают секретный пароль, воспринимается как достаточное доказательство личности пользователя**. Следовательно, безопасность сайта будет скомпрометирована, если злоумышленник сможет либо получить, либо угадать учетные данные другого пользователя.

Уязвимости в этом механизме возникают по различным причинам, одни из них:

- Возможные brute-force атаки
- Уязвимая защита от brute-force атак
- HTTP basic аутентификация

#### Brute-force атаки

Атака грубой силы - это когда злоумышленник использует систему проб и ошибок в попытке угадать действительные учетные данные пользователя. Эти атаки обычно автоматизированы с использованием словарей имен пользователей и паролей. Автоматизация этого процесса, особенно с использованием специальных инструментов, потенциально позволяет злоумышленнику совершать огромное количество попыток входа в систему с высокой скоростью.

**Brute-forcing пользовательских имен**

Имена пользователей особенно легко угадать, если они соответствуют узнаваемому шаблону, например, адресу электронной почты. Например, очень часто можно увидеть логины в формате firstname.lastname@somecompany.com. Однако, даже если нет очевидного шаблона, иногда даже высокопривилегированные учетные записи создаются с использованием предсказуемых имен пользователей, таких как админ или администратор.

**Brute-forcing паролей**

Пароли аналогичным образом могут быть перебраны, в зависимости от сложности пароля. Многие сайты принимают ту или иную форму политики паролей, которая заставляет пользователей создавать пароли с высокой энтропией, которые, по крайней мере, теоретически сложнее взломать одним перебором. Обычно это включает в себя принудительное использование в паролях:

- Минимального количества символов
- Смеси строчных и заглавных букв
- Как минимум одного специального символа

Однако, несмотря на то, что высокоэнтропийные пароли сложно взломать компьютеру, мы можем использовать базовые знания о человеческом поведении для использования уязвимостей, которые пользователи невольно привносят в эту систему. Вместо того, чтобы создавать надежный пароль со случайной комбинацией символов, пользователи часто берут пароль, который они могут запомнить, и пытаются использовать его в соответствие с политикой паролей. Например, если не разрешено использование password, пользователи могут попробовать что-нибудь вроде `P@ssw0rd` или `P4$$0rd!`.

Такое знание предсказуемых закономерностей означает, что атаки с применением грубой силы часто могут быть гораздо более изощренными и, следовательно, более эффективными, чем простые итерации через всевозможные комбинации символов.

### Уязвимая защита от brute-force атак

Высока вероятность того, что атака с применением грубой силы будет включать в себя множество неудачных попыток, прежде чем атакующий успешно скомпрометирует учетную запись. По логике вещей, защита полным перебором заключается в попытке замедлить скорость автоматизации ввода пароля, с которой злоумышленник может попытаться войти в систему. **Двумя наиболее распространенными способами предотвращения атак полным перебором являются следующие:**

- Блокировка учетной записи, к которой удаленный пользователь пытается получить доступ, если он совершает слишком много неудачных попыток входа.
- Блокировка IP адреса удаленного пользователя, если они делают слишком много попыток входа в систему

Оба подхода предлагают разную степень защиты, но ни один из них не является неуязвимым, особенно если он реализуется с использованием ошибочной логики.

Например, иногда вы можете обнаружить, что ваш IP заблокирован, если вы не можете войти слишком много раз. В некоторых реализациях счетчик количества неудачных попыток сбрасывается при успешном входе владельца IP-адреса. Это означает, что злоумышленнику просто придется входить в систему под своей учетной записью каждые несколько попыток, чтобы этот лимит никогда не был достигнут.

В этом случае достаточно просто включать свои собственные учетные данные для входа в систему через регулярные интервалы времени в течение перебора всего словаря, чтобы сделать эту защиту практически бесполезной.


### Basic аутентификация HTTP

Несмотря на то, что она достаточно старая, ее относительная простота и легкость реализации ведет к тому, что можно достаточно часто видеть испольозвание базовой аутентификации по HTTP. При базовой HTTP-аутентификации клиент получает от сервера маркер аутентификации, который строится путем сцепления имени пользователя и пароля, а также их кодировки в Base64. Этот токен хранится и управляется браузером, который автоматически добавляет его в заголовок авторизации каждого последующего запроса следующим образом:

```
Authorization: Basic base64(username:password)
```

По ряду причин это, как правило, не считается безопасным методом аутентификации. Во-первых, он **включает в себя многократную отправку учетных данных пользователя при каждом запросе**. Если на веб-сайте также не реализована HSTS, учетные данные пользователя могут быть перехвачены в ходе атаки типа "человек по середине".

Кроме того, реализация базовой аутентификации HTTP часто **не поддерживает защиту от переборов грубой силы**. Поскольку токен состоит исключительно из статических значений, это может сделать его уязвимым для перебора.

Базовая аутентификация HTTP также особенно **уязвима к атакам, связанным с сеансом, в частности к CSRF**, от которых она сама по себе не обеспечивает никакой защиты.

В некоторых случаях использование уязвимой базовой HTTP-аутентификации может дать злоумышленнику доступ только к, казалось бы, неинтересной странице. Однако, в дополнение к обеспечению дополнительной поверхности атаки, учетные данные, раскрытые таким образом, могут быть повторно использованы в других, более конфиденциальных контекстах.

### Уязвимости мультифакторной аутентификации

Многие веб-сайты полагаются исключительно на однофакторную аутентификацию с использованием пароля для аутентификации пользователей. Однако некоторые требуют от пользователей подтверждения их личности с помощью нескольких факторов аутентификации.

Проверка биометрических факторов является непрактичной для большинства веб сайтов. Однако **все чаще встречается обязательная и необязательная двухфакторная аутентификация (2FA), основанная на том, что "вы знаете"" и "что у вас есть".** Это обычно требует от пользователей ввода как традиционного пароля, так и временного верификационного кода со стороннего физического устройства, находящегося у них в распоряжении.

Хотя иногда злоумышленник может получить один фактор, основанный на знаниях, например, пароль, **вероятность одновременного получения другого фактора из стороннего источника значительно ниже.** По этой причине двухфакторная аутентификация явно более безопасна, чем однофакторная. Однако, как и любая другая мера безопасности, она безопасна настолько, насколько и ее реализация. Плохо реализованную двухфакторную аутентификацию можно обойти частично или даже полностью, точно так же, как и однофакторную аутентификацию.

**Следует также отметить, что все преимущества многофакторной аутентификации достигаются только путем проверки множества различных факторов.** Проверка одного и того же фактора двумя разными способами не является истинной двухфакторной аутентификацией. Одним из таких примеров является 2FA через электронную почту. Хотя пользователь должен предоставить пароль и проверочный код, доступ к коду предполагается на основе того, что пользователь знает учетные данные для входа в свою учетную запись электронной почты. Поэтому фактор проверки подлинности знания просто проверяется дважды.

В обход двухфакторной аутентификации возможен по разным причинам:

1. Иногда реализация двухфакторной аутентификации бывает настолько несовершенной, что ее можно обойти полностью.
2. Иногда ошибочная логика двухфакторной аутентификации означает, что после того, как пользователь выполнил начальный шаг входа в систему, веб-сайт не может адекватно проверить, что этот же пользователь выполняет второй шаг.
3. А также, как и в случае с паролями, веб-сайты должны принимать меры по предотвращению перебора проверочного кода 2FA. Это особенно важно, потому что код часто представляет собой простое 4-х или 6-значное число. Без адекватной защиты взлом такого кода тривиален.


### Уязвимости механизмов Смены пароля, Восстановления пароля, Поддержания сессии

В дополнение к базовой функциональности входа в систему, большинство сайтов предоставляют дополнительные функциональные возможности, позволяющие пользователям управлять своей учетной записью. Например, пользователи обычно могут изменить свой пароль или сбросить его, когда они его забудут. Эти механизмы также могут добавлять уязвимости, которые могут быть использованы злоумышленником.

Веб-сайты, как правило, стараются избежать известных уязвимостей на своих страницах входа. Однако **легко упустить из виду тот факт, что необходимо предпринять аналогичные шаги, чтобы убедиться в том, что связанная с ними функциональность не менее надежна**. Это особенно важно в тех случаях, когда злоумышленник может создать свою учетную запись и, следовательно, имеет легкий доступ к изучению этих дополнительных страниц.

Сторонние механизмы аутентификации, которые также могут быть уязвимы:

- Механизм поддержания сессии - "запонмить меня"
- Механизм сброса пароля через E-mail
- Механизм сброса пароля с использованием URL и одноразового токена
- Механизм смены пароля

## Как защищаться от уязвимостей механизмов аутентификации

- Где это возможно, реализуйте **многофакторную аутентификацию** для предотвращения автоматизированных атак, атак на учетные записи и методом подбора, а также повторного использования украденных учетных данных.
- Не используйте создаваемые **по умолчанию (стандартные) учетные данные**, особенно для администраторов.
- Реализуйте **проверку надежности паролей**, например, проверяя вновь создаваемые или изменяемые пароли по списку "10000 наихудших паролей".
- Установите **длину, сложность и периодичность смены паролей**.
- Обеспечьте защиту регистрации, восстановления учетных данных и API от **атак методом энумерации**, используя во всех ответах одинаковые сообщения.
- Ограничьте или значительно увеличьте **интервал между неудачными попытками входа**. Регистрируйте все неудачные попытки и уведомляйте администраторов при обнаружении атак на учетные данные, методом подбора или любых других атак.
- Используйте серверные, надежные, встроенные менеджеры сессий, генерирующие после входа в систему новые, **случайные идентификаторы с высокой степенью энтропии**. Идентификаторы сессий не должны присутствовать в URL, а должны безопасно храниться и аннулироваться после выхода из системы, простоя или наступления абсолютного тайм-аута.

## Дополнительные материалы

:::success
- Серия регулярного подкаста с обсуждением основных атак на аутентификацию и угон аккаунтов: https://t.me/cybersec_in_russian/5
- [OWASP памятка по реализации механизмов аутентификации](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md)
- [Device Cookie](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies)
:::

### Примеры из Тинькофф Банка

:::danger
- https://jira.tcsbank.ru/browse/APPSEC-939
- https://jira.tcsbank.ru/browse/APPSEC-936
- https://jira.tcsbank.ru/browse/APPSEC-1233
:::


## Oauth 2.0

OAuth 2.0 протокол, который позволяет пользователям предоставлять данные для приложений без использования логина и пароля в приложении.


OAuth 2.0 - по сути прослойка для проведения аутентификации. Во взаимодействии по правилам протокола используются следующие участники:

- user - непосредственно пользователь
- client - приложение, которое будет использовать данные пользователя после получения разрешения
- AuthServer - сервер для проведения авторизации
- Resource Server - сервер, который хранит данные ползователя в защищенном виде. Именно сюда старается попасть Client.

Разграничение доступа в протоколе контроллируется через определение scope для полученных аутентификационных данных.

Общий механизм авторизации:

![](https://i.imgur.com/4pDJk4h.png)

Протокол может использовать несколько видов алгоритма получения токена, выбирается обычно тот, который удовлетворяет требованиям приложения.

Существуют следующие варианты алгоритмов:

- Authorization Code Grant - используется для веб-приложений. Так же может быть использован мобильными приложениями
- Implicit Grant - используется одностраничниками через javascript, выполняется полностью в браузере
- Resource Owner Password Credentials Grant - может выполняться только доверенными приложениями.
- Client Credentials Grant - используется для работы устройство-устройство.


Вариант алгоритма авторизации Authorization Code Grant:

![](https://i.imgur.com/aIuVYKr.png)



## Уязвимости

### Client application

#### Неверная имплементация Implicit Grant

При этом алгоритме параметр access_token отправляетяс от Auth Server к Client через пользовательский браузер в виде URL фрагмента. Поэтому злоумышленник может подменить access_token и представиться для приложения любым пользователем.

#### Неверная обработка параметра state

Существует возможность проведения атаки типа CSRF, если:

1. Параметр state отсутствует 
2. Статичен и в каждом запросе не меняется
3. Добавляется в запрос, но не проверяется

#### Утечка приватных данных

Возможна утечка access_token. При изменении адреса для передачи токена.


### Server Auth уязвимости

#### Утечка authorization code

Возможна, если атакующий находит способ заставить сервер переслать данные на подконтрольный сервер.
Управление осуществляется через redirect_uri параметр. Получив данные об auth code, злоумышленник может сгенерировать access token.

#### Неверная валидация scope

В этом случае может быть использовано вредоносное приложение, зарегистрированное на сервере авторизации. При изменении scope может получить больше данных, чем пользователь разрешил предоставить.

#### Регистрация пользователя без верификации

Некоторые сервисы при регистрации могут не требовать подтверджения аккаунта. Эту особенность можно использовать для того чтобы провести атаку на приложение, которое предоставляет функции Oath. Злоумышленник регистрируется в основном приложении, не подтверждая учетную запись, проходит процедуру авторизации и получает доступ к основному приложению. Провести подобную атаку можно от имени любого пользователя.

Пример проблемы - https://gitlab.com/gitlab-org/gitlab/-/issues/37038

## Упражнения

### Упражнение 1

Некорректная реализация блокировки по IP от перебора грубой силой - https://portswigger.net/web-security/authentication/password-based/lab-broken-bruteforce-protection-ip-block (Сложность: низкая)

### Упражнение 2

Простой обход 2FA - https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-simple-bypass (Сложность: низкая)

### Упражнение 3

Атака грубой силы на механизм "запомнить меня" - https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie (Сложность: средняя)

### Упражнение 4

https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow

### Упражнение 5

https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking

### Упражнение 6

https://portswigger.net/web-security/oauth/openid/lab-oauth-ssrf-via-openid-dynamic-client-registration




