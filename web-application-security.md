# Безопасность web-приложений [CyberED]

## Введение в информационную безопасность и безопасность веб-приложений

### Certificates

Offensive Security Certified Professional (OSCP)
Certified Ethical Hacker (CEH)

### Work experience

Independet Security Researcher| HackerU | Kaspersky Lab

## Терминология

Краткая памятка:

 - То, что может сделать с информацией атакующий, называется **угрозой (threat)**;
 - То, благодаря чему он может это сделать, называется **уязвимостью (vulnerability)**, обусловленной **недостатком (weakness)**
 - То, как он может это сделать, называется **атакой (attack)**
 - То, с какой вероятностью злоумышленник это сделает и какие последствия это может повлечь, называется **риском (risk)**
 - То, что не позволяет атакующему провести атаку, обеспечивает **защищенность (security)**
 - То, что минимизирует риск, обеспечивает **безопасность (safety)**


## Информационная безопасность

- Защита конфиденциальности, целостности и доступности информации, а также сюда могут быть включены другие свойства, такие как подлинность, подотчетность, неотказуемость (англ. non-repudiation) и достоверность.
- Защита информации и информационных систем от неавторизованного доступа, использования, раскрытия, искажения, изменения или уничтожения в целях обеспечения конфиденциальности, целостности и доступности.
- Обеспечение защиты информации на предприятии от раскрытия неавторизованным пользователям (конфиденциальность), противоправного изменения (целостность) и недоступности, когда она необходима (доступность).
- Процесс защиты интеллектуальной собственности организации.
- Одна из дисциплин управления рисками, чьей задачей является управление стоимостью информационных рисков для бизнеса.
- Обоснованная уверенность в том, что информационные риски уравновешены соответствующими мерами контроля и управления.
- Защита информации, минимизирующая риск разглашения информации неавторизованным лицам.
- Процесс баланса между возникающими, воздействующими угрозами и успешностью противодействия этим угрозам со стороны органов государственной власти, отвечающих за безопасность государства.
- Мультидисциплинарная область исследований и профессиональной деятельности, которая сосредоточена на развитии и внедрении всевозможных механизмов безопасности (технических, организационных, человекоориентированных, юридических) с целью предохранения информации от угроз повсюду, где бы она ни находилась (как внутри периметра организации, так и за его пределами) и, соответственно, информационных систем, в которых информация создаётся, обрабатывается, хранится, передаётся и уничтожается. Перечень целей безопасности может включать конфиденциальность, целостность, доступность, неприкосновенность частной жизни, подлинность и достоверность, неотказуемость, подотчетность и проверяемость.



## Веб-приложения и уязвимости веб-приложений

Веб-сервер - сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.


Веб-сервер отвечает за предварительную обработку поступающих запросов. Он управляет сетевыми соединениями, может реализовывать кеширование и передачу запросов другим хостам.
Также он передает по определенному интерфейсу запросы программному коду на различных языках программирования.


Веб-приложение - клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети.

Использование паттернов:

- Model-View-Controller
- Model-View-Presenter
- Model-View-ViewModel
- ...

Использование фреймворков:

- Java - Spring, JSF, Struts, ...
- PHP - Laravel, Symfony, ZEND, Yii, ...
- Ruby - Ruby on rails, ...
- Python - Flask, Django, ...
- JS (Node.js) - Express.JS, Meteor.JS, ...
- C# (ASP.NET) - (ASP.NET Web Forms, ASP.NET MVC , ASP.NET Web Pages, ASP.NET Web API , ASP.NET WebHooks, SignalR), ...

Компоненты современных веб-приложений:

| Клиентская часть | Серверная часть | Хранение данных | Другие компоненты |
| ---------------- | --------------- | --------------- | ----------------- |
|   Electron       | Nginx           | Files System        | Reverse-Proxy |
|   JavaScript     | Apache          | MySQL               | Load Balancer |
|   TypeScript     | Apache Tomcat   | PostgreSQL          | Proxy Server |
|   ReactJS        | Microsoft IIS   | mongoDB             | Cache Server |
|   Redux          | Gunicorn        | Oracle              | WebSocket |
|   AngularJS      | uWSGI           | IBM DB 2            | Web Application Firewall |
|   Vue.js         | Java            | Microsoft SQL Server |  |
|   jQuery         | Python          | SQLite              |  |
|                  | PHP             | Redis               |  |
|                  | NodeJs          | Memcached           |  |
|                  | C#              | Neo4j               |  |
|                  | Go              | Tarantool           |  |
|                  | RubyOnRails     | XML                 |  |
|                  |                 | YAML                |  |


### Угрозы веб-приложений

Злоумышленники могут нанести ущерб вашему бизнесу или организации, используя ваше приложение. Подобные способы использования приложения представляют собой угрозы, которые могут (или не могут) быть достаточно серьезными, чтобы обращать на них внимание.

Списки уязвимостей и угроз приложений:

- Кратко - https://owasp.org/www-project-top-ten/ ([PDF](https://wiki.owasp.org/images/9/96/OWASP_Top_10-2017-ru.pdf))
- Развернуто - https://cwe.mitre.org/data/definitions/699.html

## Стандарты в области безопасности разработки веб-приложений

### Топ-10 OWASP

Основной целью Топ-10 OWASP является ознакомление разработчиков, проектировщиков, архитекторов, менеджеров и организаций в целом с рисками, связанными с наиболее распространенными и существенными недостатками в безопасности веб-приложений. Топ-10 также предлагает базовые способы защиты от подобных рисков и руководства по дальнейшим действиям.

### Более фундаментальные стандарты и методологии

- [Стандарт подтверждения безопасности приложений OWASP (ASVS)](https://www.owasp.org/index.php/Category:OWASP_Application_Security_Verification_Standard_Project)
- [Приложение по безопасности к Контракту на разработку ПО от OWASP. ](https://owasp.org/www-community/OWASP_Secure_Software_Contract_Annex)
- [Памятки OWASP](https://cheatsheetseries.owasp.org/index.html)
- [OWASP RRM](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology)
- [OWASP Web Security Testing Guide](https://github.com/OWASP/wstg)
- [OWASP Developers Guide](https://github.com/OWASP/DevGuide)
- [Microsoft SDL](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc307891(v=msdn.10))
- [BSIMM — Building Security In Maturity Model](https://www.bsimm.com/)
- [Эксплуатации уязвимостей](https://github.com/swisskyrepo/PayloadsAllTheThings)
- [Мониторинг актуальных уязвимостей](https://cvetrends.com/)

## Безопасная разработка

**Application Security** — это раздел безопасности, который отвечает за безопасность приложений.

**Security Development Lifecycle** (SDL, жизненный цикл безопасной разработки) — концепция разработки, заключающаяся в формировании требований к приложению, безопасном программировании, тестировании, сертификации, эксплуатации и обновлении. SDL — это процесс, который позволяет поддерживать необходимый уровень безопасности системы на этапе разработки, а затем на протяжении всего срока эксплуатации. Эта концепция фокусируется на обеспечении безопасности разрабатываемого приложения, идентификации рисков и управлении ими.

![SSDLC](https://i.imgur.com/e0DCtky.png)


## Инструменты и методологии поиска уязвимостей веб-приложений (DAST, SAST, SCA)

### Dynamic Application Security Testing (DAST)

Dynamic Application Security Testing - это процесс тестирования приложения или программного продукта в рабочем состоянии. Такой вид тестирования полезен для обеспечения защищенности актуальной версии продукта и для постоянной проверки состояния защищенности системы.

Задачи:

- Поиск незадекларированных возможностей
- Поиск неконтролируемых утечек ресурсов
- Поиск уязвимостей конфигурации развернутого приложения
- Поиск аномалий поведения при взаимодействии с входными точками приложения

### Static Application Security Testing (SAST)

Инструменты анализа исходного кода, также известные как Static Application Security Testing (SAST) Tools, предназначены для анализа исходного кода или скомпилированных версий кода, чтобы помочь найти дефекты безопасности.

Задачи:

- Поиск скрытых уязвимостей
- Поиск логических ошибок
- Поиск ошибки архитектуры
- Поиск дефетов реализации
- Поиск "Мертвого" кода
- Поиск "Закладок"
- Поддержка уровня качества кода и отклонений от стандартов

### Software Composition Analysis (SCA)

Программные решения типа Software Composition Analysis (SCA), предназначены для автоматизированного обнаружения рисков и устранения уязвимостей в коде, контроля использования внешних (готовых) библиотек.

Задачи:

- Инвентаризация всех открытых исходных кодов (OSS) и запатентованных компонентов, используемых на предприятии.
- Определение компонентов с уязвимостями безопасности, известными как Common Vulnerabilities and Exposures (CVE) (Общие уязвимости и воздействия)
- Идентифицировать компоненты с лицензиями, не соответствующими предполагаемому использованию компанией программного обеспечения.
- Обнаружение устаревших компонентов, которые больше не поддерживаются, чтобы их можно было заменить текущими версиями.
- Эффективное и быстрое распространение информации о выявленных рисках среди членов команды, которые могут принять меры по их устранению.
- Отслеживать смягчение выявленных рисков, связанных с безопасностью и лицензированием.
- Обеспечить механизм для непрерывного выполнения SCA

## Дополнительные материалы


Список популярных каналов и чатов на темы связанные с информационной безопасностью: https://t.me/YAH_Channel/191




## Уязвимости инъекции

Уязвимости, связанные, например, с внедрением SQL, NoSQL, OS и LDAP, возникают, когда непроверенные данные отправляются интерпретатору в составе команды или запроса. Вредоносные данные могут заставить интерпретатор выполнить непредусмотренные команды или обратиться к данным без прохождения соответствующей авторизации. 

Внедрения особенно распространены в старом коде. Уязвимости часто встречаются в SQL- LDAP-, XPathили NoSQL-запросах, системных командах, XMLобработчиках, SMTP-заголовках, языках выражений и ORM-запросах. Внедрения легко обнаружить при анализе кода. Сканеры и фаззеры могут помочь злоумышленникам найти подобные уязвимости.

## Инъекции команд ОС

### Что такое инъекции команд?

Инъекция команд ОС (также известная как shell инъекция) является уязвимостью веб-приложений, которая позволяет злоумышленнику выполнять произвольные команды операционной системы (ОС) на сервере, на котором запущено приложение, и, как правило, дает возможность полностью скомпрометировать приложение и все его данные. Очень часто злоумышленник может использовать уязвимость внедрения команд ОС для компрометации других частей инфраструктуры, используя доверительные отношения для перенаправления атаки на другие системы в организации.

### Как возникают инъекции команд?

Пример уязвимости инъекции команд:

```php=
$command = 'convert -pointsize 72 label:Hello  ' . $_FILES['userfile']['name'];
system($command);
```

Пример эксплуатации для уязвимости выше:

```http=
------WebKitFormBoundaryePkpFF7tjBAqx29L
Content-Disposition: form-data; name="userfile"; filename="check | ls -la;"
Content-Type: application/x-object

... contents of file goes here ...
```

### Как предотвратить инъекции команд?

На сегодняшний день наиболее эффективным способом предотвращения уязвимостей инъекции команд ОС является никогда не вызывать команды ОС из кода прикладного уровня. Практически в каждом случае существуют альтернативные способы реализации требуемой функциональности с использованием более безопасных платформенных API.

1. **Избегать прямого выполнения команд ОС**. Для огромного количества различных функций реализованы библиотеки.
2. Использовать функции языка для **вызова других программ без обращения к оболочке ОС** (proc_open в PHP)
3. **Не передавать пользовательский ввод** в командную оболочку.
4. В крайнем случае **используйте специальные функции для экранирования** (escapeshellargs в PHP)

Если считается неизбежным вызывать команды ОС с пользовательским вводом, то должна быть выполнена серьезная проверка вводимых данных:

1. Соответствие типу данных
2. Корректность формата
3. Регулярные выражения
4. Разрешенный набор символов

## Инъекции управляющих конструкций SQL

### Что такое SQL инъекция?

SQL-инъекция - это уязвимость веб-приложений, позволяющая злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, она позволяет злоумышленнику просматривать данные, которые он, как правило, не может получить. Сюда могут входить данные, принадлежащие другим пользователям, или любые другие данные, к которым само приложение может получить доступ. Во многих случаях злоумышленник может изменять или удалять эти данные, вызывая постоянные изменения содержимого или поведения приложения.

В некоторых ситуациях злоумышленник может эскалировать атаку SQL-инъекции, чтобы скомпрометировать сервер или другую внутреннюю инфраструктуру, или выполнить атаку типа "отказа в обслуживании".

### Какой ущерб несут уязвимости к инъекции SQL?

Успешная атака SQL-инъекции может привести к несанкционированному доступу к конфиденциальным данным, таким как пароли, данные кредитной карты или личная информация пользователя. Многие громкие утечки данных в последние годы стали результатом атак SQL-инъекции, что привело к репутационному ущербу и штрафам со стороны регулирующих органов. В некоторых случаях злоумышленник может получить постоянный черный ход в системы организации, что приводит к долгосрочному закреплению злоумышленника в инфраструктуре, которое может оставаться незамеченным длительный период времени.

В частности, уязвимости SQL-инъекций могут приводить к:

- Извлечению данных и возможности исследования базы данных
- Модификации информации в базе данных (удалению, добавлению, изменению)
- Обходу логики
- Обходу механизмов авторизации и аутентификации
- Чтению файлов ОС
- Выполнению команд ОС
- Отказу в обслуживании

### Примеры SQL инъекций

**Сценарий №1** Приложение использует недоверенные данные при создании следующего уязвимого SQL-вызова:

```sql=
String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";
```

**Сценарий №2** Безоговорочное доверие приложений к фреймворкам может привести к появлению уязвимых запросов (например, в языке запросов HQL):

```sql=
Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");
```

В обоих случаях злоумышленник изменяет в своем браузере значение параметра "id" для отправки `' or '1'='1`. 

Например:
`http://example.com/app/accountView?id='+or+'1'='1`

Изменение обоих запросов позволяет получить все записи из таблицы учетных данных. Более серьезные атаки позволяют изменить или удалить.

**Сценарий №3** Использование фреймворков, кажущееся безопасным, может быть обманчивым (Пример использования фреймворка Ruby On Rails и Active Records):

```sql=
User.order("#{params[:sortby]} ASC")
```

Кажущийся безопасным вызов `.order()` на самом деле не экранирует управляющих конструкций получаемых от приложения, что приводит к возможности проведения атак на базу данных, через такой вектор как:
```sql=
(CASE SUBSTR(password, 1, 1) WHEN 's' THEN 0 else 1 END)
```

#### О техниках атак

Существует широкий спектр уязвимостей, атак и методов SQL инъекции, которые возникают в различных ситуациях. К числу наиболее распространенных примеров SQL-инъекций относятся:

- SQL Injection Bypass
- Stacked queries
- Union-based
- Error-based
- Boolean blind
- Time-base
- Out of band

### Как предотвращать SQL инъекции?

Большинство случаев SQL-инъекции можно предотвратить, используя параметризованные запросы (также известные как "prepared statements") вместо конкатенации строк внутри запроса.

Также, от SQL-инъекций спасает концепция ORM (Object-Relational Mapping), но не следует ей слепо доверять.


## Дополнительные материалы
:::success
- [PayloadsAllTheThings - SQL injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)
- [PayloadsAllTheThings - NoSQL injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection)
- [OWASP NoSQL injection slides](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf)
- [PortSwigger - SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
- [SQLMap - Инструмент автоматизации](https://xakep.ru/2011/12/06/57950/)
:::


## Упражнения

### Упражнение 1

Инъекция команды ОС, простой случай - https://portswigger.net/web-security/os-command-injection/lab-simple (Сложность: Низкая)

### Упражнение 2

UNION-based атака SQL инъекции, на извлечение данных из других таблиц - https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-data-from-other-tables (Сложность: Низкая)

## Что такое внедрение шаблона на стороне сервера?

Инъекция шаблонов на стороне сервера - это атака, при которой злоумышленник может использовать собственный синтаксис шаблона для введения вредоносной полезной нагрузки в шаблон, который затем выполняется на стороне сервера.

Движки шаблонов предназначены для генерации веб-страниц путем объединения фиксированных шаблонов с изменчивыми данными. Атаки с инъекцией шаблонов на стороне сервера могут происходить, когда вводимые пользователем данные не передаются в виде данных, а непосредственно вставляются в шаблон. Это позволяет злоумышленникам вводить произвольные директивы шаблонов для манипулирования движком шаблонов, часто позволяя им получить полный контроль над сервером.

## Какой ущерб несут уязвимости к инъекции шаблонов?

Уязвимости инъекции шаблонов на стороне сервера могут подвергать веб-сайты различным атакам в зависимости от движка шаблонов и того, как именно приложение его использует. В некоторых редких случаях эти уязвимости не представляют реального риска для безопасности. Однако, в большинстве случаев, воздействие инъекции шаблона на стороне сервера может быть катастрофическим.

В самом крайнем случае злоумышленник потенциально может добиться удаленного выполнения кода, получив полный контроль над внутренним сервером и используя его для других атак на внутреннюю инфраструктуру.

Даже в тех случаях, когда полное удаленное выполнение кода невозможно, злоумышленник часто все равно может использовать внедрение шаблонов на стороне сервера в качестве основы для множества других атак, потенциально получая доступ на чтение к конфиденциальным данным и произвольным файлам на сервере.

## Как появляются уязвимости инъекции шаблонов?

Рассмотрим несколько примеров кода:

Пример НЕ уязвимый к SSTI:

```php=
<?php

require_once('lib/Twig/Autoloader.php');
Twig_Autoloader::register();

$loader = new Twig_Loader_Filesystem('views');

$twig = new Twig_Environment($loader, array(
  'cache' => 'cache',
));

echo $twig->render('index.html', array('name' => '', 'title' => 'Startpage'));

?>
```

Пример уязвимый к SSTI:

```php=
<?php

require_once('lib/Twig/Autoloader.php');
Twig_Autoloader::register();

$twig = new \Twig_Environment(new \Twig_Loader_String());

echo $twig->render("Error message: ".$_GET['error']);

?>
```

## Проведение атаки инъекции шаблонов

### Сценарий №1 Пример для кода шаблонизатора PHP Twig

Код: 
```php=
echo $twig->render("Error message: ".$_GET['error']);
```

Эксплоит:

```php=
{{['cat\x20/etc/passwd']|filter('system')}}
```

### Сценарий №2 Пример для кода шаблонизатора ASP.NET Razor

Код:
```c#=
[HttpPost]
[ValidateInput(false)]
public ActionResult Index(string razorTpl)
{
	ViewBag.RenderedTemplate = Razor.Parse(razorTpl);
	ViewBag.Template = razorTpl;
	return View();
}
```

Эксплоит:
```=
@{
  // C# code
}
```

### Сценарий №3 Пример для кода шаблонизатора Java Velocity

Код:
```java=
// Set up the context data
VelocityContext context = new VelocityContext();
context.put( "name", user.name );

// Load the template
String template = getUserTemplateFromRequestBody(request);
RuntimeServices runtimeServices = RuntimeSingleton.getRuntimeServices();
StringReader reader = new StringReader(template);
SimpleNode node = runtimeServices.parse(reader, "myTemplate");
template = new Template();
template.setRuntimeServices(runtimeServices);
template.setData(node);
template.initDocument();

// Render the template with the context data
StringWriter sw = new StringWriter();
template.merge( context, sw );
```

Эксплоит:
```=
$name.getClass().forName("java.lang.Runtime").getRuntime().exec(<COMMAND>)
```

## Как защищаться от инъекции шаблонов?

Лучший способ предотвратить инъекцию шаблонов на стороне сервера - **не позволять никаким пользователям изменять или отправлять новые шаблоны**. Однако иногда это неизбежно из-за требований бизнеса.

Один из простейших способов избежать внедрения уязвимостей инъектирования шаблонов на стороне сервера - **всегда использовать "logic-less" шаблонный движок**, такой как Mustache, если в этом нет абсолютной необходимости. Максимально возможное отделение логики от представления может значительно уменьшить вашу подверженность наиболее опасным атакам на основе шаблонов.

Другой мерой является **выполнение пользовательских шаблонов только в песочнице**, где потенциально опасные модули и функции были полностью удалены. К сожалению, недоверенный код в песочнице по своей природе сложен и склонен к обходу.

Наконец, еще одним дополнительным подходом является признание того, что произвольное выполнение кода практически неизбежно, и **применение собственной "песочницы" путем развертывания среды шаблонов**, например, в изолированном контейнере Docker.

## Дополнительные материалы
:::success
- [PayloadsAllTheThings - Templates Injections](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)
- [TPLMap: инструмент автоматизации](https://github.com/epinna/tplmap)
:::

## Упражнения

### Упражнение 1

Основы инъеции шаблонов на стороне сервера - https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic (Сложность: низкая)

### Упражнение 2

Основы инъекции шаблонов на стороне сервера (контекст кода) - https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic-code-context (Сложность: низкая)

GraphQL инъекции

Содержание:

- Что такое GraphQL
- Какие могут быть проблемы?
- Известные отчеты
- Упражнение


## Что такое GraphQL

GraphQL это язык запросов, который позволяет описать типы данных и дать возможность их собирать с помощью описанного синтаксиса.

С помощью GraphQL можно объединить разнотипные источники данных. Чаще всего используется этот язык для того чтобы получать данные от сервера.

Обычно GraphQL API состоит из:

1.  schema - описание данных
2.  queries - запрос данных
3.  resolvers - кусок кода, который описывает алгоритм преобразования данных

Проще всего рассматривать через официальный [курс](https://graphql.org/learn/).

## Какие могут быть проблемы?

- может быть реализован SSRF, если не проверяются параметры резолверов
- нарушение разграничения доступа - по-умолчанию его нет и разработчики должны самостоятельно его имплементировать
- DDOS - GraphQL не ограничивает количество вложенных элементов в запросе
- может быть использован для атак на обслуживаемые ресурсы: sql injection, Nosql injectio, Os Command Injection и т.д.
- доступных механизм интроспекции, позволяет получить данные о структуре хранилищ.

Пример запроса интроспекции:

```
{ 
 __schema { 
  types { 
   name 
   } 
  } 
}
```

Пример атак sql и nosql:

```
mutation { 
    login(input: {
        user: "admin", 
        password: "password' or 1=1 -- -"
    }) { 
        success
    } 
}

mutation {
    users(search: "{password: { $regex: \".*\"}, name:Admin }") {
        id
        name
        password
    }
}
```


## Известные отчеты

- https://gitlab.com/gitlab-org/gitlab/-/issues/215703
- https://hackerone.com/reports/1122408
- https://hackerone.com/reports/342978
- https://hackerone.com/reports/380317

## Упражнение

https://www.root-me.org/en/Challenges/Web-Server/GraphQL

Полезный ресурс для работы с GraphQL - https://apis.guru/graphql-voyager/


## Что такое Аутентификация?

Аутентификация - это процесс проверки личности конкретного пользователя или клиента. Другими словами, он включает в себя **проверку того, что они действительно те, за кого себя выдают**. По крайней мере, частично, веб-сайты открыты для всех, кто подключен к Интернету. Поэтому надежные механизмы аутентификации являются неотъемлемым аспектом веб-безопасности.

Классифицировать различные типы проверки подлинности можно по трем факторам проверки подлинности:

1. **Знание**, например, пароль или ответ на вопрос безопасности. Их иногда называют "факторами знаний".
2. **Обладание**, то есть физический объект, такой как мобильный телефон или маркер безопасности. Их иногда называют "факторами владения".
3. **Биометрия**, например, биометрия или модели поведения. Их иногда называют "факторами согласованности".

Механизмы аутентификации полагаются на целый ряд технологий для проверки одного или нескольких из этих факторов.

## Разница между аутентификацией, авторизацией и идентификацией?

Идентификация позволяет нам определить что за объект перед нами, за счет присвоения субъектам и объектам идентификатора.

Аутентификация - это процесс проверки того, действительно ли пользователь является тем, за кого он себя выдает, в то время как авторизация включает в себя проверку того, разрешено ли пользователю что-либо делать.

## Как возникают уязвимости аутентификации?

В широком смысле, большинство уязвимостей в механизмах аутентификации возникает одним из двух способов:

1. Механизмы аутентификации уязвимы, так как они **не могут адекватно защитить от атак с применением методов "грубой силы"**.
2. **Логические ошибки или плохой код** в реализации позволяют злоумышленнику полностью обойти механизмы аутентификации. 


## Какой ущерб несут уязвимости аутентификации?

Влияние уязвимостей аутентификации может быть очень серьезным. После того, как злоумышленник либо обошел аутентификацию, либо взломал учетную запись другого пользователя, он получает **доступ ко всем данным и функциональности, которыми обладает скомпрометированная учетная запись**. Если им удается скомпрометировать высокопривилегированную учетную запись, например, системного администратора, они могут получить полный контроль над всем приложением и потенциально получить доступ к внутренней инфраструктуре.

Даже компрометация низкопривилегированной учетной записи все равно может предоставить злоумышленнику доступ к данным, которые в противном случае не должны были бы быть у него, например, к коммерческой коммерческой информации. Даже если учетная запись не имеет доступа к конфиденциальным данным, она все равно может позволить злоумышленнику получить доступ к дополнительным страницам, которые обеспечивают дополнительную поверхность атаки. Часто некоторые атаки с высокой степенью вероятности будут невозможны с общедоступных страниц, но они могут быть возможны и с приватной страницы.

## Уязвимости в механизмах аутентификации

Система аутентификации веб-сайта, как правило, состоит из нескольких различных механизмов, в которых могут возникать уязвимости. Некоторые уязвимости широко применимы во всех этих контекстах, в то время как другие более специфичны с точки зрения предоставляемой функциональности.

Мы рассмотрим более подробно некоторые из наиболее распространенных уязвимостей в следующих областях:

- Уязвимости при входе в на основе пароля
- Уязвимости при многофакторной аутентификации
- Уязвимости в других механизмах аутентификации

### Уязвимости в Password-based аутентификации

Для веб-сайтов, использующих процесс входа на основе пароля, пользователи либо сами регистрируются для получения учетной записи, либо администратор присваивает им учетную запись. Эта учетная запись связана с уникальным именем пользователя и секретным паролем, который пользователь вводит в форме входа для аутентификации.

В этом сценарии, **сам факт, что они знают секретный пароль, воспринимается как достаточное доказательство личности пользователя**. Следовательно, безопасность сайта будет скомпрометирована, если злоумышленник сможет либо получить, либо угадать учетные данные другого пользователя.

Уязвимости в этом механизме возникают по различным причинам, одни из них:

- Возможные brute-force атаки
- Уязвимая защита от brute-force атак
- HTTP basic аутентификация

#### Brute-force атаки

Атака грубой силы - это когда злоумышленник использует систему проб и ошибок в попытке угадать действительные учетные данные пользователя. Эти атаки обычно автоматизированы с использованием словарей имен пользователей и паролей. Автоматизация этого процесса, особенно с использованием специальных инструментов, потенциально позволяет злоумышленнику совершать огромное количество попыток входа в систему с высокой скоростью.

**Brute-forcing пользовательских имен**

Имена пользователей особенно легко угадать, если они соответствуют узнаваемому шаблону, например, адресу электронной почты. Например, очень часто можно увидеть логины в формате firstname.lastname@somecompany.com. Однако, даже если нет очевидного шаблона, иногда даже высокопривилегированные учетные записи создаются с использованием предсказуемых имен пользователей, таких как админ или администратор.

**Brute-forcing паролей**

Пароли аналогичным образом могут быть перебраны, в зависимости от сложности пароля. Многие сайты принимают ту или иную форму политики паролей, которая заставляет пользователей создавать пароли с высокой энтропией, которые, по крайней мере, теоретически сложнее взломать одним перебором. Обычно это включает в себя принудительное использование в паролях:

- Минимального количества символов
- Смеси строчных и заглавных букв
- Как минимум одного специального символа

Однако, несмотря на то, что высокоэнтропийные пароли сложно взломать компьютеру, мы можем использовать базовые знания о человеческом поведении для использования уязвимостей, которые пользователи невольно привносят в эту систему. Вместо того, чтобы создавать надежный пароль со случайной комбинацией символов, пользователи часто берут пароль, который они могут запомнить, и пытаются использовать его в соответствие с политикой паролей. Например, если не разрешено использование password, пользователи могут попробовать что-нибудь вроде `P@ssw0rd` или `P4$$0rd!`.

Такое знание предсказуемых закономерностей означает, что атаки с применением грубой силы часто могут быть гораздо более изощренными и, следовательно, более эффективными, чем простые итерации через всевозможные комбинации символов.

### Уязвимая защита от brute-force атак

Высока вероятность того, что атака с применением грубой силы будет включать в себя множество неудачных попыток, прежде чем атакующий успешно скомпрометирует учетную запись. По логике вещей, защита полным перебором заключается в попытке замедлить скорость автоматизации ввода пароля, с которой злоумышленник может попытаться войти в систему. **Двумя наиболее распространенными способами предотвращения атак полным перебором являются следующие:**

- Блокировка учетной записи, к которой удаленный пользователь пытается получить доступ, если он совершает слишком много неудачных попыток входа.
- Блокировка IP адреса удаленного пользователя, если они делают слишком много попыток входа в систему

Оба подхода предлагают разную степень защиты, но ни один из них не является неуязвимым, особенно если он реализуется с использованием ошибочной логики.

Например, иногда вы можете обнаружить, что ваш IP заблокирован, если вы не можете войти слишком много раз. В некоторых реализациях счетчик количества неудачных попыток сбрасывается при успешном входе владельца IP-адреса. Это означает, что злоумышленнику просто придется входить в систему под своей учетной записью каждые несколько попыток, чтобы этот лимит никогда не был достигнут.

В этом случае достаточно просто включать свои собственные учетные данные для входа в систему через регулярные интервалы времени в течение перебора всего словаря, чтобы сделать эту защиту практически бесполезной.


### Basic аутентификация HTTP

Несмотря на то, что она достаточно старая, ее относительная простота и легкость реализации ведет к тому, что можно достаточно часто видеть испольозвание базовой аутентификации по HTTP. При базовой HTTP-аутентификации клиент получает от сервера маркер аутентификации, который строится путем сцепления имени пользователя и пароля, а также их кодировки в Base64. Этот токен хранится и управляется браузером, который автоматически добавляет его в заголовок авторизации каждого последующего запроса следующим образом:

```
Authorization: Basic base64(username:password)
```

По ряду причин это, как правило, не считается безопасным методом аутентификации. Во-первых, он **включает в себя многократную отправку учетных данных пользователя при каждом запросе**. Если на веб-сайте также не реализована HSTS, учетные данные пользователя могут быть перехвачены в ходе атаки типа "человек по середине".

Кроме того, реализация базовой аутентификации HTTP часто **не поддерживает защиту от переборов грубой силы**. Поскольку токен состоит исключительно из статических значений, это может сделать его уязвимым для перебора.

Базовая аутентификация HTTP также особенно **уязвима к атакам, связанным с сеансом, в частности к CSRF**, от которых она сама по себе не обеспечивает никакой защиты.

В некоторых случаях использование уязвимой базовой HTTP-аутентификации может дать злоумышленнику доступ только к, казалось бы, неинтересной странице. Однако, в дополнение к обеспечению дополнительной поверхности атаки, учетные данные, раскрытые таким образом, могут быть повторно использованы в других, более конфиденциальных контекстах.

### Уязвимости мультифакторной аутентификации

Многие веб-сайты полагаются исключительно на однофакторную аутентификацию с использованием пароля для аутентификации пользователей. Однако некоторые требуют от пользователей подтверждения их личности с помощью нескольких факторов аутентификации.

Проверка биометрических факторов является непрактичной для большинства веб сайтов. Однако **все чаще встречается обязательная и необязательная двухфакторная аутентификация (2FA), основанная на том, что "вы знаете"" и "что у вас есть".** Это обычно требует от пользователей ввода как традиционного пароля, так и временного верификационного кода со стороннего физического устройства, находящегося у них в распоряжении.

Хотя иногда злоумышленник может получить один фактор, основанный на знаниях, например, пароль, **вероятность одновременного получения другого фактора из стороннего источника значительно ниже.** По этой причине двухфакторная аутентификация явно более безопасна, чем однофакторная. Однако, как и любая другая мера безопасности, она безопасна настолько, насколько и ее реализация. Плохо реализованную двухфакторную аутентификацию можно обойти частично или даже полностью, точно так же, как и однофакторную аутентификацию.

**Следует также отметить, что все преимущества многофакторной аутентификации достигаются только путем проверки множества различных факторов.** Проверка одного и того же фактора двумя разными способами не является истинной двухфакторной аутентификацией. Одним из таких примеров является 2FA через электронную почту. Хотя пользователь должен предоставить пароль и проверочный код, доступ к коду предполагается на основе того, что пользователь знает учетные данные для входа в свою учетную запись электронной почты. Поэтому фактор проверки подлинности знания просто проверяется дважды.

В обход двухфакторной аутентификации возможен по разным причинам:

1. Иногда реализация двухфакторной аутентификации бывает настолько несовершенной, что ее можно обойти полностью.
2. Иногда ошибочная логика двухфакторной аутентификации означает, что после того, как пользователь выполнил начальный шаг входа в систему, веб-сайт не может адекватно проверить, что этот же пользователь выполняет второй шаг.
3. А также, как и в случае с паролями, веб-сайты должны принимать меры по предотвращению перебора проверочного кода 2FA. Это особенно важно, потому что код часто представляет собой простое 4-х или 6-значное число. Без адекватной защиты взлом такого кода тривиален.


### Уязвимости механизмов Смены пароля, Восстановления пароля, Поддержания сессии

В дополнение к базовой функциональности входа в систему, большинство сайтов предоставляют дополнительные функциональные возможности, позволяющие пользователям управлять своей учетной записью. Например, пользователи обычно могут изменить свой пароль или сбросить его, когда они его забудут. Эти механизмы также могут добавлять уязвимости, которые могут быть использованы злоумышленником.

Веб-сайты, как правило, стараются избежать известных уязвимостей на своих страницах входа. Однако **легко упустить из виду тот факт, что необходимо предпринять аналогичные шаги, чтобы убедиться в том, что связанная с ними функциональность не менее надежна**. Это особенно важно в тех случаях, когда злоумышленник может создать свою учетную запись и, следовательно, имеет легкий доступ к изучению этих дополнительных страниц.

Сторонние механизмы аутентификации, которые также могут быть уязвимы:

- Механизм поддержания сессии - "запонмить меня"
- Механизм сброса пароля через E-mail
- Механизм сброса пароля с использованием URL и одноразового токена
- Механизм смены пароля

## Как защищаться от уязвимостей механизмов аутентификации

- Где это возможно, реализуйте **многофакторную аутентификацию** для предотвращения автоматизированных атак, атак на учетные записи и методом подбора, а также повторного использования украденных учетных данных.
- Не используйте создаваемые **по умолчанию (стандартные) учетные данные**, особенно для администраторов.
- Реализуйте **проверку надежности паролей**, например, проверяя вновь создаваемые или изменяемые пароли по списку "10000 наихудших паролей".
- Установите **длину, сложность и периодичность смены паролей**.
- Обеспечьте защиту регистрации, восстановления учетных данных и API от **атак методом энумерации**, используя во всех ответах одинаковые сообщения.
- Ограничьте или значительно увеличьте **интервал между неудачными попытками входа**. Регистрируйте все неудачные попытки и уведомляйте администраторов при обнаружении атак на учетные данные, методом подбора или любых других атак.
- Используйте серверные, надежные, встроенные менеджеры сессий, генерирующие после входа в систему новые, **случайные идентификаторы с высокой степенью энтропии**. Идентификаторы сессий не должны присутствовать в URL, а должны безопасно храниться и аннулироваться после выхода из системы, простоя или наступления абсолютного тайм-аута.

## Дополнительные материалы

:::success
- Серия регулярного подкаста с обсуждением основных атак на аутентификацию и угон аккаунтов: https://t.me/cybersec_in_russian/5
- [OWASP памятка по реализации механизмов аутентификации](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md)
- [Device Cookie](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies)
:::

### Примеры из Тинькофф Банка

:::danger
- https://jira.tcsbank.ru/browse/APPSEC-939
- https://jira.tcsbank.ru/browse/APPSEC-936
- https://jira.tcsbank.ru/browse/APPSEC-1233
:::


## Oauth 2.0

OAuth 2.0 протокол, который позволяет пользователям предоставлять данные для приложений без использования логина и пароля в приложении.


OAuth 2.0 - по сути прослойка для проведения аутентификации. Во взаимодействии по правилам протокола используются следующие участники:

- user - непосредственно пользователь
- client - приложение, которое будет использовать данные пользователя после получения разрешения
- AuthServer - сервер для проведения авторизации
- Resource Server - сервер, который хранит данные ползователя в защищенном виде. Именно сюда старается попасть Client.

Разграничение доступа в протоколе контроллируется через определение scope для полученных аутентификационных данных.

Общий механизм авторизации:

![](https://i.imgur.com/4pDJk4h.png)

Протокол может использовать несколько видов алгоритма получения токена, выбирается обычно тот, который удовлетворяет требованиям приложения.

Существуют следующие варианты алгоритмов:

- Authorization Code Grant - используется для веб-приложений. Так же может быть использован мобильными приложениями
- Implicit Grant - используется одностраничниками через javascript, выполняется полностью в браузере
- Resource Owner Password Credentials Grant - может выполняться только доверенными приложениями.
- Client Credentials Grant - используется для работы устройство-устройство.


Вариант алгоритма авторизации Authorization Code Grant:

![](https://i.imgur.com/aIuVYKr.png)



## Уязвимости

### Client application

#### Неверная имплементация Implicit Grant

При этом алгоритме параметр access_token отправляетяс от Auth Server к Client через пользовательский браузер в виде URL фрагмента. Поэтому злоумышленник может подменить access_token и представиться для приложения любым пользователем.

#### Неверная обработка параметра state

Существует возможность проведения атаки типа CSRF, если:

1. Параметр state отсутствует 
2. Статичен и в каждом запросе не меняется
3. Добавляется в запрос, но не проверяется

#### Утечка приватных данных

Возможна утечка access_token. При изменении адреса для передачи токена.


### Server Auth уязвимости

#### Утечка authorization code

Возможна, если атакующий находит способ заставить сервер переслать данные на подконтрольный сервер.
Управление осуществляется через redirect_uri параметр. Получив данные об auth code, злоумышленник может сгенерировать access token.

#### Неверная валидация scope

В этом случае может быть использовано вредоносное приложение, зарегистрированное на сервере авторизации. При изменении scope может получить больше данных, чем пользователь разрешил предоставить.

#### Регистрация пользователя без верификации

Некоторые сервисы при регистрации могут не требовать подтверджения аккаунта. Эту особенность можно использовать для того чтобы провести атаку на приложение, которое предоставляет функции Oath. Злоумышленник регистрируется в основном приложении, не подтверждая учетную запись, проходит процедуру авторизации и получает доступ к основному приложению. Провести подобную атаку можно от имени любого пользователя.

Пример проблемы - https://gitlab.com/gitlab-org/gitlab/-/issues/37038

## Упражнения

### Упражнение 1

Некорректная реализация блокировки по IP от перебора грубой силой - https://portswigger.net/web-security/authentication/password-based/lab-broken-bruteforce-protection-ip-block (Сложность: низкая)

### Упражнение 2

Простой обход 2FA - https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-simple-bypass (Сложность: низкая)

### Упражнение 3

Атака грубой силы на механизм "запомнить меня" - https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie (Сложность: средняя)

### Упражнение 4

https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow

### Упражнение 5

https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking

### Упражнение 6

https://portswigger.net/web-security/oauth/openid/lab-oauth-ssrf-via-openid-dynamic-client-registration




## Проблемы безопасности данных

**Безопасность информации - это состояние** защищенности информации от перехвата, утечки по техническим и иным каналам, модификации, блокирования, уничтожения, несанкционированного доступа к ней, а также от нарушения функционирования или вывода из строя технических и программных средств сбора, обработки, хранения и предоставления информации, информационных и телекоммуникационных систем.

Прежде всего необходимо определить требуемый уровень защиты данных при их передаче и хранении. **Данные могут быть: персональными, конфиденциальными, секретными (защищаемые законом) или данным раскрывающими детали реализации системы.**

**Например, защищаемые законом данные:** номера кредитных карт, медицинские записи, персональные данные и коммерческие тайны требуют дополнительной защиты, особенно если они подпадают под действие закона о неприкосновенности данных (напр., Федерального закона №152 "О персональных данных", Общего регламента ЕС по защите данных (GDPR)) или закона о защите финансовых данных (напр., Стандарта безопасности данных в сфере платежных карт (PCI DSS)).

**Другим примером могут послужить данные о реализации приложения**, такие как: 
- исходные коды, 
- развернутые описания ошибок, 
- описание структуры приложения
- пр. данные, которые приложение может раскрывать при работе. 
 
Раскрытие таких данных приводит к тому, что потенциальный злоумышленник будет лучше осведомлен о работе и состоянии целевого приложения, что приведет к повышению вероятности компрометации системы.

### Примеры возникающих уязвимостей

**Сценарий №1:** Приложение шифрует номера кредитных карт в базе данных,  используя автоматическое шифрование БД. Однако эти данные  автоматически расшифровываются при извлечении, позволяя с помощью  внедрения SQL-кода получить данные кредитных карт в незашифрованном  виде.

**Сценарий №2:** Сайт не использует TLS для всех страниц или поддерживает  ненадежное шифрование. Злоумышленник может просмотреть сетевой  трафик (например, в небезопасной беспроводной сети), переключить  соединение с HTTPS на HTTP, перехватить запросы и похитить сессионные  куки. После этого он может использовать полученные куки для перехвата  сессии пользователя (прошедшего аутентификацию), изменив личные  данные пользователя. Также злоумышленник может изменить все  передаваемые данные , например, получателя денежного перевода.

**Сценарий №3:** Для сохранения паролей в базе данных не используется соль  или используется простой алгоритм хеширования. Уязвимость в загрузке  файлов позволяет злоумышленнику получить БД паролей. Все хеш-значения без соли могут быть восстановлены с помощью радужной таблицы  предварительно рассчитанных хешей. Хеш-значения, рассчитанные с  использованием простых или быстрых хеш-функций, могут быть взломаны с помощью графических процессоров, даже если для них использовалась соль.

## Шифрование передаваемых данных TLS/SSL, работа PKI и использование сертификатов x509.

Протокол TLS (transport layer security) основан на протоколе SSL (Secure Sockets Layer). 

Протокол SSL был реализован на application-уровне, непосредственно над TCP (Transmission Control Protocol), что позволяет более высокоуровневым протоколам (таким как HTTP или протоколу электронной почты) работать без изменений. 

**Если SSL сконфигурирован корректно**, то сторонний наблюдатель может узнать лишь параметры соединения (например, тип используемого шифрования), а также частоту пересылки и примерное количество данных, но не может читать и изменять их.

Протокол **TLS предназначен для предоставления трёх услуг** всем приложениям, работающим над ним, а именно: шифрование, аутентификацию и целостность. Технически, не все три могут использоваться, однако на практике, для обеспечения безопасности, как правило используются все три:

- Шифрование – сокрытие информации, передаваемой от одного компьютера к другому;
- Аутентификация – проверка авторства передаваемой информации;
- Целостность – обнаружение подмены информации подделкой.

### Шифрование в SSL/TLS

TLS и SSL используют асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и коды аутентичности сообщений для сохранения целостности сообщений.

Для обмена ключами и проверки их подлинности применяются комбинации алгоритмов: RSA (асимметричный шифр), Diffie-Hellman (безопасный обмен ключами), DSA (алгоритм цифровой подписи), ECDSA;

Для симметричного шифрования: RC4, IDEA, Triple DES, SEED, Camellia или AES;

Для проверки целостности сообщений - хеш-функций: MD5, SHA, SHA-256/384.

Алгоритмы могут дополняться в зависимости от версии протокола.

### Аутентификация в SSL/TLS

Аутентификация является неотъемлемой частью каждого TLS соединения. 

**Аутентификация в TLS работает на основе механизма «цепочки доверия»** (или «Chain of trust», если по-английски).

"Цепочкой доверия" называют цепочку сертификатов от конечного сертификата в цепочке до корневого центра сертификации, которые подтверждают подлинность последовательности от корня до конечного сертификата, при помощи подписей.

В протоколе TLS данные цепи доверия основаны на сертификатах подлинности, предоставляемых специальными органами, называемыми центрами сертификации **(CA – certificate authorities)**. Центры сертификации производят проверки и, если выданный сертификат скомпрометирован, то данный сертификат отзывается.

Из выданных сертификатов складывается уже рассмотренная цепочка доверия. Корнем её является так называемый **“Root CA certificate”** – сертификат, подписанный крупным центром, доверие к которому неоспоримо. 

### Public Key Infrastructure

Все описанное выше является часть масштабной инфраструктуры открытых ключей PKI (англ. **PKI - Public Key Infrastructure**).

PKI - это набор средств (технических, материальных, людских и т. д.), распределённых служб и компонентов, в совокупности используемых для поддержки криптозадач на основе закрытого и открытого ключей. 

В основе PKI лежит использование **криптографической системы с открытым ключом** и **несколько основных принципов**:

- закрытый ключ (private key) известен только его владельцу;
- удостоверяющий центр создает электронный документ — сертификат открытого ключа, таким образом удостоверяя факт того, что закрытый (секретный) ключ известен эксклюзивно владельцу этого сертификата, открытый ключ (public key) свободно передается в сертификате;
- никто не доверяет друг другу, но все доверяют удостоверяющему центру;
- удостоверяющий центр подтверждает или опровергает принадлежность открытого ключа заданному лицу, которое владеет соответствующим закрытым ключом.

### Сертификаты X.509

Сертификаты упомянутые выше, соответствуют особом стандарту, называющемуся стандартом X.509.

X.509 определяет стандартные форматы данных и процедуры распределения открытых ключей с помощью соответствующих сертификатов с цифровыми подписями. Эти сертификаты предоставляются удостоверяющими центрами (англ. Certificate Authority). Кроме того, X.509 определяет формат списка аннулированных сертификатов, , формат сертификатов атрибутов и алгоритм проверки подписи путём построения пути сертификации. X.509 предполагает наличие иерархической системы удостоверяющих центров для выдачи сертификатов.

Структура сертификата X.509:

- Сертификат
	- Версия
	- Серийный номер
	- Идентификатор алгоритма подписи
	- Имя издателя
	- Период действия:
		- Не ранее
		- Не позднее
	- Имя субъекта
	- Информация об открытом ключе субъекта:
	- Алгоритм открытого ключа
		- Открытый ключ субъекта
		- Уникальный идентификатор издателя (обязательно только для v2 и v3)
	- Уникальный идентификатор субъекта ​​(обязательно только для v2 и v3)
	- Дополнения (для v2 и v3)
		- Возможные дополнительные детали
- Алгоритм подписи сертификата (обязательно только для v3)
- Подпись сертификата

## Защита хранимых данных

### Шифрование (Алгоритмы шифрования)

**Шифрование** - **обратимое преобразование** информации в целях сокрытия от неавторизованных лиц, с предоставлением, в это же время, авторизованным пользователям доступа к ней. Главным образом, шифрование служит задачей соблюдения конфиденциальности передаваемой информации. Важной особенностью любого алгоритма шифрования является использование ключа, который утверждает выбор конкретного преобразования из совокупности возможных для данного алгоритма.

С помощью шифрования обеспечиваются три состояния безопасности информации:

- **Конфиденциальность** - Шифрование используется для скрытия информации от неавторизованных пользователей при передаче или при хранении.
- **Целостность** - Шифрование используется для предотвращения изменения информации при передаче или хранении.
- **Идентифицируемость** - Шифрование используется для аутентификации источника информации и предотвращения отказа отправителя информации от того факта, что данные были отправлены именно им.

#### Шифры

**Симметричное** шифрование использует **один и тот же ключ** и для зашифровывания, и для расшифровывания.

**Асимметричное** шифрование использует два и более разных ключeq: одини для зашифровывания (которые также называется открытыми), другие для расшифровывания (называется закрытыми).

##### Виды шифров

Виды симметричных шифров:

- Блочные шифры
	- AES (англ. Advanced Encryption Standard) — американский стандарт шифрования
	- ГОСТ 28147-89 — советский и российский стандарт шифрования, также является стандартом СНГ (Аналог 3DES)
	- DES (англ. Data Encryption Standard) — стандарт шифрования данных в США
	- 3DES (Triple-DES, тройной DES)
	- RC2 (Шифр Ривеста (Rivest Cipher или Ron’s Cipher))
	- RC5
	- Blowfish
	- Twofish
	- IDEA (International Data Encryption Algorithm, международный алгоритм шифрования данных)
	- CAST (по инициалам разработчиков Carlisle Adams и Stafford Tavares)
	- Kuznechik
- Потоковые шифры
	- RC4 (алгоритм шифрования с ключом переменной длины)
	- SEAL (Software Efficient Algorithm, программно-эффективный алгоритм)
	- WAKE (World Auto Key Encryption algorithm, алгоритм шифрования на автоматическом ключе)

Виды асимметричных шифров:

- RSA (Rivest-Shamir-Adleman)
- DSA (Digital Signature Algorithm)
- Elgamal (Шифросистема Эль-Гамаля)
- Diffie-Hellman (Обмен ключами Диффи — Хелмана)
- ECDSA (Elliptic Curve Digital Signature Algorithm) — алгоритм с открытым ключом для создания цифровой подписи.
- ГОСТ Р 34.10-2012
- Rabin
- Luc
- McEliece
- Криптосистема Уильямса

### Хеширование (Использование соли и перца)

Хеш-функция (англ. hash function от hash — «превращать в фарш», «мешанина»), или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины в (выходную) битовую строку установленной длины, выполняемое определённым алгоритмом. 

Преобразование, производимое хеш-функцией, называется хешированием. Исходные данные называются входным массивом, «ключом» или «сообщением». Результат преобразования (выходные данные) называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».

Хеш-функции применяются в следующих случаях:

- при построении ассоциативных массивов;
- при поиске дубликатов в сериях наборов данных;
- при построении уникальных идентификаторов для наборов данных;
- при вычислении контрольных сумм от данных (сигнала) для последующего обнаружения в них ошибок (возникших случайно или внесённых намеренно), возникающих при хранении и/или передаче данных;
- при сохранении паролей в системах защиты в виде хеш-кода (для восстановления пароля по хеш-коду требуется функция, являющаяся обратной по отношению к использованной хеш-функции);
- при выработке электронной подписи (на практике часто подписывается не само сообщение, а его «хеш-образ»);
- и др.

В общем случае (согласно принципу Дирихле) нет однозначного соответствия между хеш-кодом (выходными данными) и исходными (входными) данными. Возвращаемые хеш-функцией значения (выходные данные) менее разнообразны, чем значения входного массива (входные данные). Случай, при котором хеш-функция преобразует более чем один массив входных данных в одинаковые сводки, называется «коллизией». Вероятность возникновения коллизий используется для оценки качества хеш-функций.

Для того, чтобы хеш-функция считалась криптографически стойкой, она должна удовлетворять трём основным требованиям, на которых основано большинство применений хеш-функций в криптографии:

- Необратимость: для заданного значения хеш-функции `m` должно быть практически невозможно найти блок данных `X`, для которого `H(X)=m`.
- Стойкость к коллизиям первого рода: для заданного сообщения M должно быть практически невозможно подобрать другое сообщение N, для которого `H(N)=H(M)`.
- Стойкость к коллизиям второго рода: должно быть практически невозможно подобрать пару сообщений (M,M'), имеющих одинаковый хеш. (Такие коллизии найти легче, чем предыдущие, что может доказать [Парадокс дней рождений](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%B4%D0%BD%D0%B5%D0%B9_%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F))


Существует множество алгоритмов хеширования, отличающихся различными свойствами. Примеры свойств:

- разрядность;
- вычислительная сложность;
- криптостойкость.

## Проблемы утечки данных через раскрытие информации

Раскрытие информации, также известное как утечка информации - может происходить когда веб-сайт непреднамеренно раскрывает конфиденциальную информацию своим пользователям. В зависимости от контекста, сайты могут раскрывать все виды информации потенциальному злоумышленнику, в том числе:

- Данные о других пользователях, такие как имена пользователей или финансовая информация.
- Конфиденциальные коммерческие или деловые данные
- Техническая информация о сайте и его инфраструктуре

Опасность утечки конфиденциальных данных о пользователе или бизнесе достаточно очевидна, но раскрытие технической информации иногда может быть столь же серьезным. Хотя некоторая часть этой информации будет иметь ограниченное применение, она может стать отправной точкой для раскрытия дополнительной поверхности атаки, которая может содержать другие интересные уязвимости. Знание, которое вы можете собрать, может даже обеспечить недостающую часть головоломки при попытке построения сложных, высоконадежных атак.

Иногда конфиденциальная информация может небрежно просочиться к пользователям, которые просто просматривают сайт в обычном режиме. Однако чаще всего злоумышленнику необходимо добиться раскрытия информации, взаимодействуя с веб-сайтом неожиданными или вредоносными способами. Затем они тщательно изучают ответы сайта, чтобы попытаться определить интересное поведение.

### Примеры раскрытия информации

Ниже приведены некоторые основные примеры раскрытия информации:

- раскрытие имен скрытых каталогов, их структуры и содержимого с помощью файла robots.txt или списка каталогов
- предоставление доступа к файлам с исходным кодом через резервные копии
- явное упоминание в сообщениях об ошибках названий таблиц или столбцов баз данных
- непреднамеренное раскрытие конфиденциальной информации, такой как реквизиты кредитных карт
- API-ключи, IP-адреса, учетные данные базы данных и т.д. в исходном коде
- намеки на существование или отсутствие ресурсов, имен пользователей и т.д. через тонкие различия в поведении приложения

### Как возникают уязвимости в раскрытии информации?

Уязвимости раскрытия информации могут возникать самыми разными способами, но в широком смысле их можно разделить на следующие категории:

- Раскрытие внутренней информации по ошибке. Например, комментарии разработчиков в разметке иногда видны пользователям в производственной среде.
- Небезопасная конфигурация веб-сервера и связанных с ним технологий. Например, неспособность отключить функции отладки и диагностики может иногда предоставить злоумышленникам полезные инструменты, которые помогут им получить конфиденциальную информацию. Конфигурация по умолчанию также может сделать веб-сайт уязвимым, например, отображая слишком подробные сообщения об ошибках.
- Ошибки в проектировании и поведение приложения. Например, если веб сайт возвращает различные ответы при возникновении различных состояний ошибок, это также может позволить злоумышленникам перечислять конфиденциальные данные, такие как действительные учетные данные пользователя.

## Как предотвратить уязвимости в раскрытии информации

Полностью предотвратить раскрытие информации сложно из-за огромного разнообразия способов, которыми это может произойти. Однако существуют некоторые общие лучшие практики, которым можно следовать, чтобы свести к минимуму риск такого рода уязвимостей, проникающих на ваши собственные веб-сайты.

- **Классифицируйте данные**, обрабатываемые, хранимые или передаваемые приложением. Определите какие из них являются конфиденциальными согласно законам о неприкосновенности данных, нормативам или бизнес требованиям.
- Убедитесь, что **все, кто участвует в создании сайта, полностью осведомлены о том, какая информация считается конфиденциальной**. Иногда кажущаяся безобидной информация может быть гораздо более полезной для злоумышленника, чем люди думают. Выделение этих опасностей может помочь убедиться в том, что конфиденциальная информация в целом более безопасно обрабатывается вашей организацией.
- **Проверяйте любой код** на предмет потенциального раскрытия информации как часть процесса контроля качества или построения. Должно быть относительно легко автоматизировать некоторые задачи, такие как удаление комментариев разработчиков.
- Насколько это возможно, **используйте общие сообщения об ошибках**. Не предоставляйте злоумышленникам подсказки о поведении приложений без необходимости.
- Перепроверяйте, что любые **отладочные или диагностические функции отключены** в производственной среде.
- Убедитесь, что **вы полностью понимаете настройки конфигурации** и последствия для безопасности любой сторонней технологии, которую вы реализуете. Уделите время изучению и отключению любых функций и параметров, которые вам на самом деле не нужны.
- **Не храните конфиденциальные данные без необходимости**. Сразу удаляйте их или используйте токенизацию или усечение, соответствующие стандарту PCI DSS. Данные, которые не сохраняются, нельзя украсть.
- **Обеспечьте шифрование** всех хранимых конфиденциальных данных.
- Обеспечьте применение современных и надежных алгоритмов, протоколов и ключей, а также используйте соответствующие механизмы управления ключами.
- **Сохраняйте пароли с помощью** надежных, адаптивных функций **хеширования с солью и фактором трудоемкости** (задержки), таких как Argon2, scrypt, bcrypt или PBKDF2.

## Дополнительные материалы

:::success
- Детали работы протокола TLS (https://tls12.ulfheim.net/, https://tls13.ulfheim.net/)
- [Проактивная защита OWASP: Защита данных](https://owasp.org/www-project-proactive-controls/#7:_Protect_Data)
- [OWASP Памятка о хранении паролей](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
- [OWASP Памятка об использовании шифрования](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)
- [Памятка о HSTS](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html)
:::

## Упражнения

### Упражнение 1 (Сложность: низкая)

Взломать следующие хеши и HMAC последовательности.

Использовать инструмент Hashcat в дистрибутиве Kali Linux.

Использовать словарь `rockyou` по ссылке: https://github.com/danielmiessler/SecLists/raw/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz

1. JWT - eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiZ3Vlc3QifQ.4kBPNf7Y6BrtP-Y3A-vQXPY9jAh_d0E6L4IUjL65CvmEjgdTZyr2ag-TM-glH6EYKGgO3dBYbhblaPQsbeClcw
2. SHA1 - 144187f494c533ab47d18777b1a3bc40bd9022c2
3. BCrypt - `$2y$06$Ti80gPoyZtdr5jIqYMOyWuoGus.MlxZAUr2i1G2nOSToLtXDys/b6`
4. MD5 - 2624b6d87f0039085175f8b7b72ac394

### Упражнение 2 (Сложность: высокая)

Взлом шифрованных данных через уязвимости бизнес-логики (https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-encryption-oracle)



## Уязвимости подделки запросов от имени сервера и инъекции внешних XML сущностей.

Перед тем как приступить к знакомству с уязвимостью к инъекции внешних сущностей XML (XML external entity (XXE)) необходимо разобраться почему это может быть настолько опасной уязвимостью. Для этого мы первоначально разберем уязвимость которая, чаще всего является последствием к уязвимости XXE - подделку запроса от имени сервера (Server-side request forgery (SSRF)).

## Подделка запроса от имени сервера (SSRF)

### Что это такое? 

Подделка запросов на стороне сервера (также известная как SSRF) - это уязвимость веб-безопасности, которая позволяет злоумышленнику побудить серверное приложение делать HTTP-запросы к произвольному домену по выбору злоумышленника.

В типичных примерах SSRF злоумышленник может заставить сервер подключиться обратно к самому себе или к другим веб-службам в инфраструктуре организации, или к внешним системам сторонних производителей.

### Почему такие уязвимости появляются? 

Целевое приложение может иметь функциональные возможности для импорта данных из URL-адреса, публикации данных на URL-адрес или иного чтения данных из URL-адреса, который может быть взломан. Атакующий модифицирует вызовы к этой функциональности, предоставляя совершенно другой URL или манипулируя тем, как строятся URL (обход путей и т.д.).

```php=
<?php

/**
* Check if the 'url' GET variable is set
* Example - http://localhost/?url=http://testphp.vulnweb.com/images/logo.gif
*/
if (isset($_GET['url'])){
$url = $_GET['url'];

/**
* Send a request vulnerable to SSRF since
* no validation is being done on $url
* before sending the request
*/
$image = fopen($url, 'rb');

/**
* Send the correct response headers
*/
header("Content-Type: image/png");

/**
* Dump the contents of the image
*/
fpassthru($image);}
```

Когда манипулируемый запрос поступает на сервер, код на стороне сервера подхватывает манипулируемый URL и пытается прочитать данные к измененному URL. 

### К чему такие уязвимости могут привести?

Успешная атака SSRF часто может привести к несанкционированным действиям или доступу к данным внутри организации, либо в самом уязвимом приложении, либо на других внутренних системах, с которыми приложение может взаимодействовать. В некоторых ситуациях уязвимость SSRF может позволить злоумышленнику выполнить произвольную команду или прочесть файл ОС.

Эксплойт SSRF, вызывающий подключения к внешним системам сторонних производителей, может привести к вредоносным последующим атакам, которые, будут исходить от организации, размещающей уязвимое приложение, что может привести к потенциальной юридической ответственности и ущербу для репутации.

**Целевые URL могут быть:**

- Облачный сервер мета-данных - Облачные сервисы, такие как AWS, предоставляют REST-интерфейс на http://169.254.169.254/, где можно извлечь важную конфигурацию и иногда даже ключи аутентификации.
- HTTP Интерфейсы базы данных - NoSQL базы данных, такие как MongoDB, обеспечивают REST интерфейсы на HTTP портах. Если ожидается, что база данных будет доступна только для внутренних нужд, аутентификация может быть отключена, и злоумышленник может извлечь данные
- Внутренние интерфейсы REST
- Файлы - атакующий может читать файлы, используя URI <file://>.

### Примеры SSRF атак

#### Атаки SSRF на сам сервер

При SSRF-атаке на сам сервер злоумышленник побуждает приложение сделать HTTP-запрос обратно на сервер, на котором находится приложение, через его сетевой интерфейс loopback. Это обычно включает в себя предоставление URL-адреса с именем хоста, например 127.0.0.1 (зарезервированный IP-адрес, указывающий на адаптер обратного шлейфа) или localhost (обычно используемое имя для того же адаптера).

#### SSRF-атаки на другие внутренние системы

Другой пример атак, который часто возникает при подделке запросов на стороне сервера, это когда сервер приложений способен взаимодействовать с другими внутренними системами, которые не доступны непосредственно пользователям. Эти системы часто имеют немаршрутизируемые частные IP-адреса. Так как внутренние системы обычно защищены сетевой топологией, они часто имеют более слабую защиту. Во многих случаях внутренние внутренние системы содержат чувствительную функциональность, к которой может получить доступ без аутентификации тот, кто способен взаимодействовать с системами.

### Обход защиты от SSRF

Часто встречаются приложения, содержащие поведение SSRF вместе с защитой, нацеленной на предотвращение вредоносной эксплуатации. И часто эти средства защиты можно обойти.

#### SSRF с входными фильтрами на основе черного списка

Некоторые приложения блокируют вход, содержащий имена хостов, такие как 127.0.0.1 и localhost, или чувствительные URL, такие как /admin. В этой ситуации вы часто можете обойти фильтр, используя различные техники:

- Используя альтернативное IP представление 127.0.0.1, например 2130706433, 017700000001 или 127.1.
- Регистрация собственного доменного имени, которое разрешает 127.0.0.1. Для этой цели вы можете использовать spoofed.jack.su.
- Путаница заблокированных строк с использованием кодировки URL или вариации регистра.
- DNS Rebinding изменяя IP адрес доменного имени после первого его разрешения (Пример: http://1u.ms/)

#### SSRF с входными фильтрами на основе белого списка

Некоторые приложения разрешают ввод только тех значений, которые совпадают, начинаются с или содержат белый список разрешенных значений. В этой ситуации вы можете иногда обойти фильтр, используя несоответствия в разборе URL.

Спецификация URL содержит ряд функций, которые могут быть пропущены при реализации специального разбора и проверки URL-адресов:

- Вы можете встраивать учетные данные в URL перед именем хоста, используя символ @. Например: https://expected-host@evil-host.
- Вы можете использовать символ # для указания фрагмента URL. Например: https://evil-host#expected-host.
- Вы можете использовать иерархию DNS имен, чтобы поместить требуемый ввод в переопределенное DNS имя, которое вы контролируете. Например: https://expected-host.evil-host.
- Вы можете использовать символы в кодировке URL, чтобы запутать код URL-парсинга. Это особенно полезно, если код, реализующий фильтр, обрабатывает символы в кодировке URL, отличной от кода, выполняющего внутренний HTTP-запрос.
- Вы можете использовать атаки на неконсистентность проверок, в т.ч. DNS Rebinding
- Вы можете проводить атаки инъекции символов переносов строк и реализовывать технику "Контрабанды запросов"
- Вы можете использовать комбинации этих методов вместе.

#### Обход фильтра SSRF через открытую переадресацию

Иногда можно обойти любые виды защиты на основе фильтров, воспользовавшись открытой уязвимостью перенаправления.

Для примере SSRF предположим, что URL, предоставленный пользователем, строго проверен, чтобы предотвратить злонамеренное использование поведения SSRF. Однако приложение, чей URL-адрес разрешен, содержит открытую уязвимость перенаправления. При условии, что API, используемое для выполнения запросов поддерживает обработку перенаправлений, вы можете построить URL, который удовлетворяет фильтру и приводит к перенаправленному запросу на желаемую часть внутренней цели.

Например, предположим, что приложение содержит открытую уязвимость перенаправления, в которой указан следующий URL:

http://white.listed.site/product/nextProduct?currentProductId=6&path=http://evil-site.net

### Как защищаться от таких уязвимостей?

Для защиты от атак SSRF следует заранее резолвить доменные имена и превращать IP-адреса в нормальные представления, после чего проверять IP адрес на соответствие его белому списку разрешенных адресов и явно указывать в API для выполнения сетевого обращения проверенный ранее адрес, добавляя в HTTP-заголовок `Host`, то имя или адрес, который получили от приложения, чтобы не нарушить правила обращения к виртуальным хостам.

## Инъекция внешних сущностей XML

### Что это такое? 

Инъекция внешних сущностей XML (также известная как XXE) - это уязвимость веб-безопасности, позволяющая злоумышленнику вмешиваться в обработку XML-данных приложения. Часто она позволяет злоумышленнику просматривать файлы на файловой системе сервера приложений, а также взаимодействовать с любыми внутренними или внешними системами, к которым имеет доступ само приложение.

В большом числе случаев злоумышленник может усилить атаку XXE для компрометации основного сервера или другой внутренней инфраструктуры, используя уязвимость XXE для выполнения атак на подделку запроса на стороне сервера (SSRF).

### Почему такие уязвимости появляются? 

Некоторые приложения используют формат XML для передачи данных между браузером и сервером. Приложения, которые делают это практически всегда используют стандартную библиотеку или платформенный API для обработки XML-данных на сервере. Уязвимости XXE возникают из-за того, что спецификация XML содержит различные потенциально опасные функции, и стандартные парсеры поддерживают эти функции, даже если они обычно не используются приложением.

Узнайте о формате XML, DTD и внешних сущностях.

Внешние сущности XML - это тип пользовательских сущностей XML, определенные значения которых загружаются извне DTD, в котором они объявлены. Внешние сущности особенно интересны с точки зрения безопасности, так как они позволяют определить сущность, основываясь на содержимом пути к файлу или URL.

Пример кода XML документа:

```xml=
<?xml version="1.0" encoding="UTF-8" ?>    <- заголовок
<!DOCTYPE greeting [                       <- Определение
  <!ELEMENT greeting (#PCDATA)>               типа
]>                                            документа
<greeting>Hello, world!</greeting>         <- данные
<internal>&#060;internal&#062;</internal>
```

Пример инъекции внешних сущностей в XML документ:

```xml=
<?xml version='1.0'?>
<!DOCTYPE element [
<!ENTITY name SYSTEM "file:///etc/passwd" >]>
<element><xxx>Hello, &name;</xxx></element>
```

В дополнение:
:::info
[Больше об XML сущностях](https://portswigger.net/web-security/xxe/xml-entities)
:::

### К чему такие уязвимости могут привести?

Атак инъекции XXE позволяют провести множество различных вариаций векторов атак, например:

- Использование XXE для получения файлов, где определяется внешняя сущность, содержащая содержимое файла, и возвращается в ответе приложения.
- Использование XXE для выполнения SSRF атак, где внешняя сущность определяется на основе URL на внутреннюю систему.
- Использование слепой инъекции XXE с отправкой данных за рамки клиент-серверного приложения, где конфиденциальные данные передаются с сервера приложения на систему, контролируемую злоумышленником.
- Использование слепого XXE для получения данных с помощью сообщений об ошибках, где злоумышленник может вызвать сообщение об ошибке разбора, содержащее конфиденциальные данные.
- Использование XXE для проведения атак отказа в обслуживании (англ. Distributed Denial of Service (DDoS)).

### Примеры XXE 

Для выполнения атаки XXE инъекции, в результате которой произвольный файл извлекается из файловой системы сервера, вам необходимо **изменить представленный XML двумя способами**:

- Ввести (или отредактировать) **элемент DOCTYPE**, который определяет внешнюю сущность, содержащую путь к файлу.
- Отредактировать **значение данных в XML**, которое возвращается в ответе приложения, чтобы использовать определенную внешнюю сущность.

Например, предположим, что торговое приложение проверяет уровень запасов продукта, отправляя следующий XML на сервер:

```xml=
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
```

Приложение не выполняет никакой специфической защиты от атак XXE, поэтому вы можете использовать уязвимость XXE для получения файла `/etc/passwd`, отправив следующую полезную нагрузку XXE:

```xml=
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```

Эта полезная нагрузка XXE определяет внешнюю сущность `&xxe;` значение которой является содержимым файла `/etc/passwd` и использует сущность в пределах значения `productId`. Это приводит к тому, что в ответ приложения включается содержимое файла:

```=
Invalid product ID: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

### Как защищаться от таких уязвимостей?

Практически все уязвимости XXE возникают из-за того, что библиотека разбора XML приложения поддерживает потенциально опасные возможности XML, которые приложению не нужны или которые оно не намерено использовать. Самый простой и эффективный способ предотвратить XXE-атаки - это отключить эти функции.

Как правило, достаточно отключить разрешение внешних сущностей и отключить поддержку XInclude. Обычно это может быть сделано с помощью опций конфигурации или программным переопределением поведения по умолчанию. Обратитесь к документации по библиотеке разбора XML или API для получения подробной информации о том, как отключить ненужные функции.

Пример отключения парсинга внешний сущностей для стандартного парсера Java:

```java=
dbf = javax.xml.parsers.DocumentBuilderFactory.newInstance()
dbf.setExpandEntityReferences(false);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(<XML Source>);
```

## Дополнительные материалы

:::success
- Новая эра SSRF атак (Видео): https://www.youtube.com/watch?v=D1S-G8rJrEk
- Новая эра SSRF атак (Слайды): https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf
- SSRF Библия v2: https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf
- [PayloadsAllTheThings - Server Side Request Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [Техники эксплуатации уязвимостей Blind SSRF](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)
- [PayloadsAllTheThings - XXE Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection)
:::


## Упражнения

- https://portswigger.net/web-security/ssrf
- https://portswigger.net/web-security/xxe

### Упражнение 1

Базовая SSRF против локального сервера - https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-localhost

### Упражнение 2

Эксплуатация XXE с использованием внешних сущностей для получения файлов - https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files

### Упражнение 3

Использование XXE для выполнения атак SSRF - https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-perform-ssrf




## Уязвимости контроля доступа

### Что такое контроль доступа

Контроль доступа (или авторизация) - это применение ограничений на то, кто (или что) может совершать попытки действий или получать доступ к запрошенным ресурсам. В контексте веб-приложений контроль доступа зависит от аутентификации и управления сеансами:

- Аутентификация идентифицирует пользователя и подтверждает, что он является тем, за кого себя выдает.
- Управление сеансом идентифицирует, какие последующие HTTP-запросы выполняются тем же самым пользователем.
- Управление доступом определяет, разрешено ли пользователю выполнять действия, которые он пытается выполнить.

Сломанный контроль доступа является часто встречающейся и часто критической уязвимостью безопасности. Проектирование и управление контролем доступа - это сложная и динамичная проблема, которая применяет деловые, организационные и правовые ограничения к технической реализации. Проектные решения по контролю доступа должны приниматься людьми, а не технологиями, и вероятность ошибок высока.

С точки зрения пользователя, контроль доступа можно разделить на следующие категории:

- Вертикальный контроль доступа
- Горизонтальный контроль доступа
- Контекстно-зависимый контроль доступа

### Вертикальный контроль доступа

Вертикальный контроль доступа - это механизмы, ограничивающие доступ к чувствительным функциям, недоступным другим типам пользователей.

С помощью вертикальных средств контроля доступа различные типы пользователей имеют доступ к различным функциям приложений. Например, администратор может изменить или удалить учетную запись любого пользователя, в то время как обычный пользователь не имеет доступа к этим действиям. Вертикальные средства контроля доступа могут быть более тонкой реализацией моделей безопасности, разработанных для внедрения бизнес-политик, таких как разделение обязанностей и наименьших привилегий.

#### Пример уязвимостей IFLAC

Insecure Function Level Access Control (IFLAC) - это подкатегория уязвимостей контроля доступа. Уязвимый контроль доступа функционального уровня может позволить злоумышленникам получить доступ к несанкционированным для роли злоумышленника функциям. Административные функции являются основной целью данного типа атак. 

Данная уязвимость возникает, когда приложение публикует функциональный интерфейс (Например, API), в котором не проверяется уровень доступа для обращения к определенным в интерфейсе функциям. В таком случае злоумышленник может вызывать функции приложения, которые дают ему привилегии не задуманные для использования уровнем роли злоумышленника.

Примером может послужить возможность обращения к вызову функции удаления пользователя, в то время как доступ в административную панель для низкопривилегированного пользователя формально закрыт. Т.е. пользователь не может открыть кабинет администратора, но может выполнить запрос к методу API, который будет успешно выполнен. Пример:

```
http://web.site/admin/deleteUser?username=carlos
```

См. Упражнение 1.

**Примеры с HackerOne:**

- [Пример с GitLab](https://hackerone.com/reports/502593)

### Горизонтальный контроль доступа

Горизонтальный контроль доступа - это механизмы, ограничивающие доступ к ресурсам для пользователей, которым специально разрешен доступ к этим ресурсам.

С помощью горизонтального контроля доступа различные пользователи имеют доступ к подмножеству ресурсов одного и того же типа. Например, банковское приложение позволит пользователю просматривать транзакции и осуществлять платежи со своих счетов, но не со счетов любого другого пользователя.

#### Пример уязвимостей IDOR

Небезопасные прямые ссылки на объекты (IDOR) - это также подкатегория уязвимостей контроля доступа. IDOR возникает, когда приложение использует пользовательский ввод для прямого доступа к объектам, а злоумышленник может модифицировать ввод для получения несанкционированного доступа. Он был популярен своим появлением в первой десятке OWASP 2007 Top Ten, хотя это лишь один из примеров многих ошибок в реализации, которые могут привести к обходу контроля доступа.

Рассмотрим сайт, который использует следующий URL для доступа к странице учетной записи клиента, извлекая информацию из внутренней базы данных:

https://insecure-website.com/customer_account?customer_number=132355

Здесь номер клиента используется непосредственно как индекс записи в запросах, которые выполняются на внутренней базе данных. Если другие элементы управления отсутствуют, злоумышленник может просто изменить значение параметра customer_number, минуя элементы управления доступом для просмотра записей других клиентов. Это пример уязвимости IDOR, приводящей к горизонтальному повышению привилегий.

Атакующий может выполнить горизонтальное и вертикальное повышение привилегий, изменяя пользователя на пользователя с дополнительными привилегиями в обход элементов управления доступом. Другие возможности включают в себя, например, использование утечки пароля или изменение параметров после того, как злоумышленник попал на страницу учетной записи пользователя.

См. Упражнение 2.

**Примеры с HackerOne:**

- [IDOR в DoD](https://hackerone.com/reports/1004745)
- [IDOR в магазине](https://hackerone.com/reports/287789)
 
### Контроль доступа в местах зависящих от бизнес-логики

Контекстно-зависимые элементы управления доступом ограничивают доступ к функциональности и ресурсам в зависимости от состояния приложения или взаимодействия с ним пользователя.

Контекстно-зависимые элементы управления доступом препятствуют выполнению пользователем действий в неправильном порядке. Например, веб-сайт розничной торговли может помешать пользователю изменить содержимое корзины после того, как он произвел оплату.

### Как исключать возникновение уязвимостей контроля доступа?

Уязвимости контроля доступа, как правило, можно предотвратить, применяя глубокий подход к защите и следуя следующим принципам:

- Никогда не полагайтесь только на обфускацию для контроля доступа.
- Если ресурс не предназначен для публичного доступа, запретите доступ по умолчанию.
- Где это возможно, используйте единый прикладной механизм для обеспечения контроля доступа.
- На уровне кода, сделайте обязательным для разработчиков объявление доступа, разрешенного для каждого ресурса, и запретите доступ по умолчанию.
- Тщательно проверяйте и тестируйте средства контроля доступа, чтобы убедиться, что они работают так, как задумано.
- Регистрировать сбои контроля доступа и уведомлять администраторов при необходимости (например, если сбои повторяются);
- ограничивать частоту доступа к API и контроллерам для минимизации ущерба от инструментов автоматизации атак;

## Уязвимости разграничения доступа к каталогам (Directory traversal)

### Что это такое? 

Обратный путь в каталогах (также известный как обход файловых путей) - это уязвимость веб-безопасности, позволяющая злоумышленнику читать произвольные файлы на сервере, на котором запущено приложение. Сюда могут входить код приложения и данные, учетные данные для внутренних систем и конфиденциальные файлы операционной системы. В некоторых случаях злоумышленник может записать в произвольные файлы на сервере, что позволит ему изменить данные или поведение приложения, и, в конечном счете, получить полный контроль над сервером.

### Почему такие уязвимости появляются? 

Уязвимости Directory Traversal появляются из-за отсутствия валидации входных данных пользователя, а также из-за отсутствия разграничения доступа приложения или функции на возможность обращаться к файловым ресурсам всего сервера.

Пример уязвимого кода:

```php=
<?php
$template = 'red.php';
if (isset($_COOKIE['TEMPLATE'])) {
    $template = $_COOKIE['TEMPLATE'];
}
include "/home/users/phpguru/templates/" . $template;
```

### Чтение файлов при помощи Directory traversal

Рассмотрим торговое приложение, которое отображает изображения предметов для продажи. Изображения загружаются через некоторый HTML, как показано ниже:

```xml
<img src="/loadImage?filename=218.png">
```

URL loadImage принимает параметр имени файла и возвращает содержимое указанного файла. Сами файлы образов хранятся на диске в каталоге `/var/www/images/`. Чтобы вернуть образ, приложение добавляет запрашиваемое имя файла в этот базовый каталог и использует API файловой системы для чтения содержимого файла. В описанном выше случае приложение читает по следующему пути к файлу:

```
/var/www/images/218.png
```

Приложение не реализует защиту от атак обхода директорий, поэтому злоумышленник может запросить следующий URL для получения произвольного файла из файловой системы сервера:

```
https://insecure-website.com/loadImage?filename=../../../etc/passwd
```

Это приводит к тому, что приложение читает по следующему пути к файлу:

```
/var/www/images/.../.../.../etc/passwd
```

Последовательность `../` действительна внутри пути к файлу и означает повышение на один уровень в структуре каталога. Три последовательных `../` последовательности идут вверх от `/var/www/images/` до корня файловой системы, и таким образом файл, который действительно читается:

```
/etc/passwd
```

В операционных системах на базе Unix это стандартный файл, содержащий информацию о пользователях, зарегистрированных на сервере.

В Windows, как `../`, так и `..\` являются действительными последовательностями обхода директорий, и эквивалентной атакой для получения стандартного файла операционной системы была бы атака:

```
https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini.
```

Примеры с HackerOne:

- [PTrav в Node.js](https://hackerone.com/reports/311216)
- [PTrav в GitLab](https://hackerone.com/reports/827052)

### Как защищаться от уязвимостей разграничения доступа к каталогам?

Наиболее эффективным способом предотвращения уязвимостей, связанных с обходом файловых путей, является полное предотвращение передачи пользовательского ввода в API файловой системы. Многие функции приложения, которые это делают, могут быть переписаны, чтобы обеспечить такое же поведение более безопасным способом.

Если считается неизбежным передавать пользовательский ввод в API файловой системы, то для предотвращения атак следует использовать три уровня защиты:

- Приложение должно проверить пользовательский ввод, прежде чем обрабатывать его. В идеале, проверка должна сравниваться с белым списком разрешенных значений. Если это невозможно для требуемой функциональности, то валидация должна проверить, что вход содержит только разрешенное содержимое, например, чисто буквенно-цифровые символы.
- После проверки входных данных, приложение должно добавить входные данные в базовый каталог и использовать API файловой системы платформы для канонизации пути. Оно должно проверить, что канонизированный путь начинается с ожидаемого базового каталога.
- После получения имени запрашиваемого файла, приложение должно разграничивать доступ к файлам возможным для доступа на уровне ОС, в соответствии с требованиями приложения, для того чтобы избежать возможных обходов парсинга пути файла и пр. возможностей.

Ниже приведен пример простого Java-кода для проверки канонического пути к файлу на основе пользовательского ввода:

```java=
File file = new File(BASE_DIRECTORY, userInput);
if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) {
    // process file
}
```

## Дополнительные материалы
:::success
- [Как избегать уязвимостей Directory Traversal](https://wiki.owasp.org/index.php/File_System#Path_traversal)
- [PayloadsAllTheThings - Directory Traversal](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Directory%20Traversal)
:::


## Упражнения

- https://portswigger.net/web-security/access-control
- https://portswigger.net/web-security/file-path-traversal

### Упражнение 1

Незащищенная функциональность администратора с непредсказуемым URL-адресом - https://portswigger.net/web-security/access-control/lab-unprotected-admin-functionality-with-unpredictable-url (Сложность: низкая)

### Упражнение 2

Небезопасные прямые ссылки на объекты (IDOR) - https://portswigger.net/web-security/access-control/lab-insecure-direct-object-references (Сложность: низкая)

### Упражнение 3

Directory traversal, простой случай - https://portswigger.net/web-security/file-path-traversal/lab-simple (Сложность: низкая)





## Уязвимости конфигурации

Уязвимости конфигурации приложения или его компонентов возникают из-за некорректной или непродуманной настройки самих компонентов или их параметров безопасности, что приводит к возможности компрометации приложения или нарушения безопасной работы отдельных его функций.

## Почему такие уязвимости появляются?

Уязвимости конфигурации приложения и его компонентов весьма разнообразны, что нельзя назвать одну или несколько причин их возникновения. Наиболее частыми причинами возникновения уязвимостей являются случаи когда:
- любой из компонентов приложения недостаточно защищен или разрешения облачных сервисов некорректно настроены;
- включены или присутствуют лишние функции (например, неиспользуемые порты, службы, страницы, учетные записи или привилегии);
- учетные записи и пароли, создаваемые по умолчанию, используются без изменений;
- обработка ошибок позволяет осуществить трассировку стека или получить слишком подробные сообщения об ошибках;
- отключены или некорректно настроены последние обновления безопасности;
- не выбраны безопасные значения параметров защиты серверов приложений, фреймворков (например, Struts, Spring, ASP.NET), библиотек и т. п.;
- сервер не использует безопасные заголовки или директивы, а также если они некорректно настроены;
- ПО устарело или имеет компоненты с известными уязвимостями.

## К чему зачастую такие уязвимости приводят и в чем проявляются?

Примеры сценариев атак:

- Сценарий №1. Сервер приложений поставляется с образцами приложений, которые не удаляются с рабочего сервера. Эти приложения содержат известные уязвимости, позволяющие злоумышленникам скомпрометировать сервер. Если одно из этих приложений является консолью администратора, а стандартные учетные записи не менялись, то атакующий может войти в приложение и перехватить контроль над ним, используя стандартный пароль. 
- Сценарий №2. На сервере не отключен вывод списка файлов в каталогах, что позволяет злоумышленнику найти и выгрузить скомпилированные Java классы, после декомпиляции и обратного анализа которых можно просмотреть исходный код. В результате атакующий может обнаружить уязвимости и получить доступ к приложению. 
- Сценарий №3. Сервер приложений настроен на отправку подробных сообщений об ошибках, включая данные о трассировке стека. Это может привести к разглашению важной информации, например, о версии компонента, содержащей известные уязвимости. 
- Сценарий №4. Поставщик облачных услуг использует стандартные разрешения общего доступа через интернет для других пользователей облака. Это позволяет получить доступ к конфиденциальной информации, доступной в облачном хранилище

## Распространенные примеры уязвимостей конфигурации приложения

### Уязвимости раскрытия отладочной информации

Уязвимости раскрытия отладочной информация возникают когда веб-приложение генерирует сообщения об ошибках, содержащие конфиденциальную информацию о его среде, пользователях или связанных с ними данных.

Трассировка стека может раскрывать потенциально конфиденциальную информацию, такую как: физические пути к соответствующим файлам, фрагменты исходного кода, информация о версии различных пакетов, информация о базе данных, сообщения об ошибках, ...

В данном случае, рекомендуется обрабатывать исключения внутренне и не показывать пользователю ошибки, содержащие потенциально конфиденциальную информацию.

Примеры:

- [Java Stack trace](https://hackerone.com/reports/41469)
- [PHP Stack trace](https://hackerone.com/reports/150018)
- [Apache Status](https://hackerone.com/reports/541347)

### Уязвимости присущие веб-фреймворкам

Веб-фреймворк - это каркас, предназначенный для создания динамических веб-сайтов, сетевых приложений, сервисов или ресурсов. Он упрощает разработку и избавляет от необходимости написания рутинного кода. Многие фреймворки упрощают доступ к базам данных, разработку интерфейса, и также уменьшают дублирование кода.

Абсолютное большинство фреймворков имеют файлы конигурации, конфигурацию по умолчанию и параметры безопасности, а также плагины и модули влияющие на безопасность всего приложения. Все эти компоненты могут иметь не эталонные значения и нести угрозу из-за некорректной настройки функций обеспечения безопасности.

Примеры:

- [Spring Boot Actuator](https://www.acunetix.com/vulnerabilities/web/spring-boot-actuator/) 
- [ASP.NET application trace enabled](https://www.acunetix.com/vulnerabilities/web/asp-net-application-trace-enabled/)
- [RoR Security](https://guides.rubyonrails.org/security.html)
- [Apache Tomcat Manager](https://www.tenable.com/plugins/was/98525)

### Уязвимости конфигурации коробочных приложений

Коробочные приложения, которые используются как компненты для поддержания работы основного веб-приложения, или представляющие собой целевое веб-приложение, предоставляющее некий сервис, могут быть уязвимы сами по себе. Как из-за обнаруживаемых там уязвимостей, так и из-за небезопасной конфигурации этих приложений.

Примеры:

- [Gitlab Directory Traversal](https://snyk.io/vuln/SNYK-DEBIANUNSTABLE-GITLAB-560292)
- [Jenkins weak password](https://www.acunetix.com/vulnerabilities/web/jenkins-weak-password/)
- [Jira SSRF](https://jira.atlassian.com/browse/JRASERVER-69793)

### Уязвимости присущие веб-серверам

Зачастую веб-серверы страдают от уязвимостей ошибок конфигурации не меньше приложений, работающих на их основе. Популярные веб-серверы имеют весьма гибкие возможности настройки, что приводит и к плачевным последствиям в случае ошибок возникающих в их мощном функционале.

Пример уязвимостей встречающихся в конфигурационных файлах сервера Nginx:

#### [public-php-fpm] Общедоступный php-fpm

В Example можно увидеть, что FastCGI-сервер находится не на unix сокете, а на порту 9000. 

```nginx
47:  fastcgi_pass  $server_addr:9000; 
```

Можно предположить, что порт не локальный, а доступен снаружи. Если это так, то существует возможность исполнять произвольный PHP-код. 

Пример использования php-fpm с Unix-socket:
```nginx
location ~ \.php$ {
  try_files $uri =404;
  fastcgi_pass unix:/var/run/php5-fpm/DOMAINNAME.socket;
  fastcgi_index index.php;
  include /etc/nginx/fastcgi_params;
}
```

#### [alias_traversal] Path traversal при использовании alias

Директива [alias](https://nginx.ru/ru/docs/http/ngx_http_core_module.html#alias) используется для замены пути указанного локейшена.
К примеру, для конфигурации:
```nginx
location /i/ {
    alias /data/w3/images/;
}
```

на запрос `/i/top.gif` будет отдан файл `/data/w3/images/top.gif`.

Однако, если локейшен не оканчивается разделителем директорий (`/`):
```nginx
location /i {
    alias /data/w3/images/;
}
```
то на запрос `/i../app/config.py` будет отдан файл `/data/w3/app/config.py`.

Иными словами, не корректная конфигурация `alias` может позволить злоумышленнику прочесть файл за пределами целевой директории.

##### Что делать?

Все довольно просто:

  - необходимо найти все директивы `alias`;
  - убедится что вышестоящий префиксный локейшен оканчивается на `/`.

#### [host_spoofing] Подделка заголовка запроса Host

Зачастую, приложению, стоящему за Nginx, необходимо передать корректный заголовок `Host` для корректной генерации различных URL-адресов (редиректы, ресурсы, ссылки в письмах и т.д.).
Возможность его подмены злоумышленником может повлечь множестве проблем от фишинговых атак до SSRF, поэтому следует избегать таких ситуаций.

> Возможно, ваше приложение так же ориентируется на заголовок запроса `X-Forwarded-Host`.
> В этом случае вам необходимо самостоятельно позаботится о его корректной установке при проксировании.

##### Как самостоятельно обнаружить?

Чаще всего эта проблема возникает в результате использования переменной `$http_host` вместо `$host`.

Несмотря на их схожесть, они сильно отличаются:
  * `$host` - хост в порядке приоритета: имя хоста из строки запроса, или имя хоста из заголовка `Host` заголовка запроса, или имя сервера, соответствующего запросу;
  * `$http_host` - заголовок запроса "Host".

Пример такой конфигурации:
```nginx
location @app {
  proxy_set_header Host $http_host;
  # Other proxy params
  proxy_pass http://backend;
}
```

##### Что делать?

К счастью, все довольно очевидно:

  * перечислить корректные имена сервера в директиве `server_name`;
  * всегда использовать переменную `$host`, вместо `$http_host`.

##### Дополнительная информация

  * [Host of Troubles Vulnerabilities](https://hostoftroubles.com/)
  * [Practical HTTP Host header attacks](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)

## Как избежать уязвимостей конфигурации?

Необходимо реализовать процесс безопасной настройки, включая:

- воспроизводимость процессов для быстрого создания безопасных, изолированных сред. Среды для разработки, контроля качества и эксплуатации должны быть настроены одинаково, но иметь разные учетные данные. Процессы должны быть автоматизированы для минимизации затрат на создание новых безопасных сред; 
- использование платформ только с необходимым набором функций, компонентов, документации и образцов. Удалите или не устанавливайте лишние компоненты или фреймворки; 
- проверку и актуализацию параметров настройки безопасности в соответствии с выпускаемыми бюллетенями, обновлениями и исправлениями (см. A9:2017-Использование компонентов с известными уязвимостями), а также проверку разрешений облачных хранилищ (например, для контейнеров S3); 
- создание сегментированной архитектуры приложения, обеспечивающей эффективное разграничение компонентов или клиентов с помощью контейнеризации или облачных групп безопасности; 
- использование безопасных директив для клиентов, например, Безопасных заголовков; 
- автоматизацию проверки эффективности используемых конфигураций и настроек во всех средах.

## Дополнительные материалы
:::success
- [Разбор уязвимой конфигурации веб-сервера Nginx (Задания №5. NGINX config)](https://habr.com/ru/company/dsec/blog/461077/)
- [Обнаружение и перечисление контейнеров Amazon S3](https://blog.websecurify.com/2017/10/aws-s3-bucket-discovery.html)
- [Руководство по настройке заголовков безопасности](https://habr.com/ru/company/southbridge/blog/471746/)
:::


## Упражнения 

- https://portswigger.net/web-security/information-disclosure

### Упражнение 1

Раскрытие информации в истории контроля версий - https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-in-version-control-history (Сложность: средняя)

### Упражнение 2

Раскрытие исходного кода через резервные файлы - https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-via-backup-files (Сложность: низкая)




## Cross-Site Scripting (XSS)

Прежде чем знакомиться с уязвимостями и атаками межсайтового скриптнига, необходимо изучить основные механизмы работы браузера, а также встроенные механизмы защиты.

## Браузер и механизмы защиты

Для ускоренного ознакомления с механизмами защиты в браузерах мы рассмотрим только несколько важных механизмов безопасности. Но если вы хотите узнать о них больше, посетите ссылку: [Web security](https://developer.mozilla.org/en-US/docs/Web/Security)

### Same Origin Policy

Политика одного источника (англ. Same Origin Policy (SOP)) является критическим механизмом безопасности, который ограничивает то, как документ или скрипт, загруженный из одного источника, может взаимодействовать с ресурсом из другого источника. Он помогает изолировать потенциально вредоносные документы, уменьшая возможные векторы атаки.

#### Определение "источника"

Два URL-адреса имеют один и тот же "источник", если протокол, порт (если он указан) и хост одинаковы для обоих.

В следующей таблице приведены примеры сравнения источников с URL http://store.company.com/dir/page.html:

| URL | Результат | Причина |
|-----| ------- | ------ |
| http://store.company.com/dir2/other.html | Тот же источник | Отличается только путь |
| http://store.company.com/dir/inner/another.html | Тот же источник | Отличается только путь |
| https://store.company.com/page.html | Источник не совпадает | Отличаются протоколы |
| http://store.company.com:81/dir/page.html | Источник не совпадает | Отличается порт (http:// имеет порт 80 по умолчанию) |
| http://news.company.com/dir/page.html | Источник не совпадает | Отличает доменное имя |


#### Межсайтовый сетевой доступ

Политика одного источника контролирует взаимодействие между двумя различными источниками, например, когда вы используете `XMLHttpRequest` или элемент `<img>`. Эти взаимодействия обычно делятся на три категории:

- Межсайтовая отправка данных обычно разрешена. Примерами таких взаимодействий являются ссылки, перенаправления и форма отправки. Некоторые HTTP-запросы требуют предварительного запроса.
- Обычно разрешено встраивание межсайтовых данных. (Примеры приведены ниже).
- Обычно, межсайтовое чтение запрещено, но при встраивании часто происходит получение доступа на чтение. Например, Вы можете прочитать размеры встроенного изображения, действия встроенного скрипта или доступность встроенного ресурса.

Приведем несколько примеров ресурсов, которые могут быть встроены межсайтово:

- JavaScript с `<script src="..."></script>`. Подробная информация об ошибках синтаксиса доступна только для скриптов с одного и того же источника.
- CSS применяется с `<link rel="stylesheet" href="...">`. Из-за ослабленных синтаксических правил CSS, межсайтовый CSS требует правильного заголовка `Content-Type`. Ограничения варьируются в зависимости от браузера: Internet Explorer, Firefox, Chrome, Safari (см. CVE-2010-0051) и Opera.
- Изображения отображаются с помощью `<img>`.
- Мультимедиа, воспроизводимые с помощью `<video>` и `<audio>`.
- Внешние ресурсы, встроенные с помощью `<object>` и `<embed>`.
- Шрифты, применяемые с `@font-face`. В некоторых браузерах разрешены межсайтовые шрифты, в других - шрифты одного и того же источника.
- Все, что встроено с помощью `<iframe>`. Сайты могут использовать заголовок `X-Frame-Options` для предотвращения межсайтового открытия фреймов.

#### Как разрешить перекрестный доступ?

Используйте CORS для разрешения межсайтового доступа. CORS является частью HTTP, которая позволяет серверам указывать любые другие хосты, с которых браузер должен разрешать загрузку контента.

### Cross-origin resource sharing (CORS)

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Считается, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Больше о CORS рекомендуется узнать на сайте: https://developer.mozilla.org/ru/docs/Web/HTTP/CORS

## Атаки на клиентскую часть

Основные виды атак на клиентов, через клиентскую часть приложения это:

- Cross-site scripting (XSS)
- Cross-site request forgery (CSRF)
- Clickjacking (UI redressing)
- Cross-origin resource sharing (CORS) Misconfiguration
- DOM-based vulnerabilities

В сегодняшней лекции мы рассмотрим только несколько атак, об остальных атаках вы можете получить информацию на сайте https://portswigger.net/web-security/all-materials.

### Cross-site scripting (XSS)

Межсайтовый скриптинг (также известный как XSS) - это уязвимость веб-безопасности, позволяющая злоумышленнику компрометировать взаимодействие пользователей с уязвимым приложением. Она позволяет злоумышленнику обходить политику одного источника (Same Origin Policy (SOP)), которая предназначена для разделения различных веб сайтов друг от друга. Уязвимости межсайтового скриптинга, как правило, позволяют злоумышленнику маскироваться под пользователя-жертву, выполнять любые действия, которые может выполнить пользователь, и получать доступ к любым данным пользователя. Если пользователь-жертва имеет привилегированный доступ внутри приложения, то атакующий может получить полный контроль над всей функциональностью и данными приложения.

#### Как работает XSS?

Межсайтовый скриптинг работает путем манипулирования уязвимым веб-сайтом, чтобы он возвращал пользователям вредоносный JavaScript. Когда вредоносный код выполняется внутри браузера жертвы, злоумышленник может полностью скомпрометировать их взаимодействие с приложением.

#### Типы XSS-атак?

Существует три основных типа XSS-атак. Это:

- Отраженный XSS, где вредоносный скрипт происходит из текущего HTTP запроса.
- Хранимый XSS, где вредоносный скрипт приходит из хранилища данных веб-сайта.
- Dom-based XSS, где уязвимость существует в клиентском коде, а не в коде сервера.

#### Отраженный XSS

Отраженный межсайтовый скриптинг (или XSS) возникает, когда приложение получает данные в HTTP-запросе и включает эти данные непосредственно в ответ небезопасным способом.

Предположим, что веб-сайт имеет функцию поиска, которая получает пользовательское поисковое слово в параметре URL:

```
https://insecure-website.com/search?term=gift
```

В ответе на этот URL приложение отвечает с заданным поисковым термином:

```xml
<p>Вы искали: gift</p>.
```

Предполагая, что приложение не выполняет никакой другой обработки данных, атакующий может построить следующий вектор атаки:

```
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>.
```

Этот URL-адрес приводит к следующему ответу:

```xml
<p>Вы искали: <script>/* Bad stuff here... */</script></p>
```

Если другой пользователь приложения сделает запрос по URL злоумышленника, то скрипт, предоставленный злоумышленником, будет выполнен в браузере пользователя-жертвы, в контексте его сеанса работы с приложением.

#### Хранимый XSS

Сохраненный межсайтовый скриптинг (также известный как скриптинг второго порядка или постоянный XSS) возникает, когда приложение получает данные из недоверенного источника и включает эти данные в свои последующие HTTP-ответы небезопасным способом.

Предположим, что веб-сайт позволяет пользователям оставлять комментарии к записям в блогах, которые отображаются другим пользователям. Пользователи отправляют комментарии, используя HTTP-запрос, как показано ниже:

```=
POST / post/comment HTTP/1.1
Хост: vulnerable-website.com
Content-Length: 100

postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net
```

После того, как этот комментарий будет отправлен, любой пользователь, посетивший пост в блоге, получит следующий комментарий в рамках ответа приложения:

```xml
<p>This post was extremely helpful.</p>
```

Если предположить, что приложение не выполняет никакой другой обработки данных, злоумышленник может отправить такой вредоносный комментарий:

```xml
<script>/* Bad stuff here... */</script>
```
В запросе злоумышленника этот комментарий будет иметь URL-адрес как:

```
comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E
```

Любой пользователь, посетивший пост в блоге, теперь получит следующий ответ в рамках ответа приложения:

```xml
<p><script>/* Bad stuff here... */</script></p>
```

Скрипт, предоставленный злоумышленником, будет затем выполнен в браузере пользователя-жертвы в контексте его сеанса работы с приложением.

#### Dom-based XSS

XSS-уязвимости, основанные на DOM, обычно возникают, когда JavaScript берет данные из подконтрольного злоумышленнику источника, например, URL, и передает их "раковине" (англ. Sink), поддерживающей динамическое выполнение кода, например, `eval()` или `innerHTML`. Это позволяет злоумышленникам выполнять вредоносный JavaScript, что обычно позволяет взламывать учетные записи других пользователей.

Для реализации XSS-атаки, основанной на DOM, необходимо поместить данные в источник таким образом, чтобы они распространились на поглотитель и вызвали выполнение произвольного JavaScript.

Наиболее распространенным источником для DOM XSS является URL, доступ к которому обычно осуществляется с помощью объекта `windows.location`. Злоумышленник может построить ссылку для отправки жертвы на уязвимую страницу с полезной нагрузкой в строке запроса и фрагментами URL. В некоторых случаях, например, при нацеливании на страницу 404 или на сайт, работающий на PHP, полезная нагрузка также может быть помещена в путь.

#### Как защищаться от атак XSS

Предотвращение межсайтового скриптинга в некоторых случаях тривиально, но может быть намного сложнее в зависимости от сложности приложения и способов обработки данных, контролируемых пользователем.

В целом, эффективное предотвращение уязвимостей XSS, чаще всего, предполагает сочетание следующих мер:

- Ввод фильтра для входных данных. В момент получения пользовательского ввода, фильтровать как можно строже, основываясь на том, что ожидается или допустимо.
- Кодировать данные на выходе. В момент, когда пользовательские данные выводятся в ответах HTTP, кодируйте выходные данные, чтобы предотвратить их интерпретацию в качестве активного содержимого. В зависимости от контекста вывода, это может потребовать применения комбинаций HTML, URL, JavaScript и CSS кодирования.
- Используйте соответствующие заголовки ответов. Для предотвращения XSS в ответах HTTP, которые не предназначены для HTML или JavaScript, можно использовать заголовки `Content-Type` и `X-Content-Type-Options`, чтобы убедиться, что браузеры интерпретируют ответы так, как вы собираетесь.
- Политика безопасности контента (англ. Content Security Policy (CSP)). В качестве последнего пункта защиты вы можете использовать Content Security Policy (CSP), чтобы уменьшить серьезность любых XSS-уязвимостей, которые все еще могут встречаться.

### Cross-site request forgery (CSRF)

Подделка межсайтовых запросов (также известная как CSRF) - это уязвимость веб-безопасности, позволяющая злоумышленнику склонить пользователей к выполнению действий, которые они не намерены выполнять. Она позволяет злоумышленнику частично обходить одну и ту же политику происхождения, которая предназначена для предотвращения вмешательства различных веб сайтов друг в друга.

#### Какой ущерб могут нанести атаки CSRF?

При успешной атаке CSRF злоумышленник заставляет пользователя-жертву совершить непреднамеренное действие. Например, это может заключаться в изменении адреса электронной почты их аккаунта, смене пароля или осуществлении денежного перевода. В зависимости от характера действия, злоумышленник может получить полный контроль над учетной записью пользователя. Если взломанный пользователь имеет привилегированную роль в приложении, то злоумышленник может получить полный контроль над всеми данными и функциональностью приложения.

#### Как CSRF работает?

Для того, чтобы атака CSRF была возможной, должны быть выполнены три ключевых условия:

- Соответствующее действие. Внутри приложения есть действие, которое злоумышленник имеет причину побудить. Это может быть как привилегированное действие (например, изменение разрешений для других пользователей), так и любое действие, связанное с пользовательскими данными (например, изменение собственного пароля пользователя).
- Поддержание сеанса на основе куки-файлов. Выполнение действия включает в себя произведение одного или нескольких HTTP-запросов, и приложение полагается исключительно на куки сессии, чтобы идентифицировать пользователя, который сделал запрос. Не должно быть никакого другого механизма для отслеживания сессий или проверки запросов пользователей.
- Нет непредсказуемых параметров запроса. Запросы, выполняющие действие, не содержат параметров, значения которых злоумышленник не может определить или угадать. Например, при смене пользователем пароля, функция не является уязвимой, если атакующему необходимо знать значение существующего пароля.

Например, предположим, что в приложении есть функция, позволяющая пользователю изменять адрес электронной почты в своей учетной записи. Когда пользователь выполняет это действие, он делает HTTP-запрос, как показано ниже:

```=
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```

Это соответствует условиям, требуемым для CSRF:

- Действие по изменению адреса электронной почты на учетной записи пользователя представляет интерес для злоумышленника. После этого действия злоумышленник, как правило, может спровоцировать смену пароля и получить полный контроль над учетной записью пользователя.
- Приложение использует сессионный cookie-файл для идентификации того, какой пользователь отправил запрос. Нет других маркеров или механизмов для отслеживания сеансов пользователя.
- Атакующий может легко определить значения параметров запроса, необходимых для выполнения действия.

При наличии этих условий злоумышленник может создать веб-страницу, содержащую следующий HTML:

```=
<html>
  <body>
    <form action="https://vulnerable-website.com/email/change" method="POST">
      <input type="hidden" name="email" value="pwned@evil-user.net" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

Если пользователь-жертва зайдет на веб-страницу злоумышленника, произойдет следующее:

- Страница злоумышленника спровоцирует HTTP-запрос на уязвимый веб-сайт.
- Если пользователь входит на уязвимый веб-сайт, его браузер автоматически включает в запрос сессионные cookie-файлы (при условии, что cookie-файлы SameSite не используются).
- Уязвимый веб-сайт будет обрабатывать запрос обычным способом, относиться к нему, как к сделанному пользователем-жертвой, и изменять свой адрес электронной почты.

#### Предотвращение CSRF-атак

Наиболее надежным способом защиты от атак CSRF является включение маркера CSRF в соответствующие запросы. Токен должен быть:

- Непредсказуемым с высокой энтропией, как и для токенов сеанса в целом.
- Привязанный к сеансу пользователя.
- Строго проверяться в каждом случае перед выполнением соответствующего действия.

Работа с Same Site Cookie:

![](https://i.imgur.com/2hOvKWR.jpg)


## Дополнительные материалы

:::success
- [Больше о безопасности браузера](https://developer.mozilla.org/en-US/docs/Web/Security)
- [Борьба с CSRF при помощи SameSite Cookies](https://portswigger.net/web-security/csrf/samesite-cookies)
- [Использование CSRF-токенов](https://portswigger.net/web-security/csrf/tokens)
- [Памятка по защите от CSRF атак](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- [Злоупотребление аудитором XSS от Chrome для кражи токенов](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens)
:::

## Упражнения

- https://portswigger.net/web-security/cross-site-scripting
- https://portswigger.net/web-security/csrf

### Упражнение 1

Хранение XSS в HTML-контексте без кодировки - https://portswigger.net/web-security/cross-site-scripting/stored/lab-html-context-nothing-encoded (Сложность: низкая)

### Упражнение 2

CSRF-уязвимость без защиты - https://portswigger.net/web-security/csrf/lab-no-defenses (Сложность: низкая)










## Insecure Deserialization

Сериализация - это процесс преобразования сложных структур данных, таких как объекты и их поля, в "более плоский" формат, который можно передавать и получать в виде последовательного потока байтов. 

![](https://i.imgur.com/68m6RpE.png)

Сериализация данных значительно упрощает этот процесс:

- Запись сложных данных в межпроцессную память, в файл или в базу данных.
- Отправка сложных данных, например, по сети, между различными компонентами приложения или в вызовах API.

Очень важно, что при сериализации объекта его состояние также сохраняется. Другими словами, сохраняются атрибуты объекта вместе с присвоенными им значениями.

## Сериализация vs дезериализации

Десериализация - это процесс восстановления этого потока байтов до полнофункциональной копии оригинального объекта, в точном состоянии, в котором он был сериализован. Логика сайта может затем взаимодействовать с этим десериализованным объектом, так же, как и с любым другим объектом.

Многие языки программирования предлагают встроенную поддержку сериализации. Именно то, как сериализуются объекты, зависит от языка. Некоторые языки сериализуют объекты в двоичные форматы, в то время как другие используют различные форматы строк, с разной степенью удобочитаемости для человека. Обратите внимание, что все атрибуты оригинального объекта хранятся в сериализованном потоке данных, включая любые приватные поля. Чтобы предотвратить сериализацию поля, оно должно быть явно помечено как "переходное" в объявлении класса.

Имейте в виду, что при работе с различными языками программирования сериализация может называться marshalling (Ruby) или pickling (Python). В этом контексте эти термины являются синонимами "сериализации".


### Сериализация в Java

Подробнее о процессе сериализации: https://habr.com/ru/post/60317/

Пример класса:
```java
import java.io.Serializable;

class TestSerial implements Serializable {
  public byte count = 0;
  public byte version = 100;
}
```

Пример сериализованного объекта из класса:
```
AC ED 00 05 73 72 00 0A 53 65 72 69 61 6C 54 65
73 74 A0 0C 34 00 FE B1 DD F9 02 00 02 42 00 05
63 6F 75 6E 74 42 00 07 76 65 72 73 69 6F 6E 78
70 00 64
```

Давайте рассмотрим, что собой представляет каждый байт в сериализованном объекте. В начале идёт информация о протоколе сериализации:
* `AC ED`: STREAM_MAGIC. Говорит о том, что используется протокол сериализации.
* `00 05`: STREAM_VERSION. Версия сериализации.
* `0x73`: TC_OBJECT. Обозначение нового объекта.

На первом шаге алгоритм сериализации записывает описание класса ассоциированного с объектом. В примере был сериализован объект класса TestSerial, следовательно алгоритм начал записывать описание класса TestSerial.
* `0x72`: TC_CLASSDESC. Обозначение нового класса.
* `00 0A`: Длина имени класса.
* `53 65 72 69 61 6c 54 65 73 74`: TestSerial, имя класса.
* `A0 0C 34 00 FE B1 DD F9`: SerialVersionUID, идентификатор класса.
* `0x02`: Различные флаги. Этот специфический флаг говорит о том, что объект поддерживает сериализацию.
* `00 02`: Число полей в классе.

Теперь алгоритм записывает поле byte version = 100;.
* `0x42`: Код типа поля. 42 это «B», которое закреплено за Byte.
* `00 05`: Длина имени поля.
* `63 6F 75 6E 74 42`: count, имя поля.

Затем алгоритм записывает следующее поле, byte version = 100; и заканчивает описание полей класса.
* `0x42`: Код типа поля. 
* `00 07`: Длина имени поля.
* `76 65 72 73 69 6F 6E`: version, имя поля.
* `0x78`: TC_ENDBLOCKDATA, конец опционального блока данных для объекта.
* `0x70`: TC_NULL, обозначает то что больше нет суперклассов, потому что мы достигли верха иерархии классов.

До этого алгоритм сериализации записывал описание классов ассоциированных с объектом. Теперь будут записаны фактические данные ассоциированные с объектом.

* `00`: Значение поля count - 0
* `64`: Значение поля Version - 100

### Сериализация в ASP.NET

ASP.NET имеет специальный класс для бинарной сериализации BinaryFormatter.Serialize, который располагается в пространстве имен:
`System.Runtime.Serialization.Formatters.Binary`

:::danger
Методы сериализации BinaryFormatter устарели и запрещены в приложениях ASP.NET

Ссылка: https://docs.microsoft.com/ru-ru/dotnet/core/compatibility/core-libraries/5.0/binaryformatter-serialization-obsolete
Дата публикации: 01.11.2020
:::

Пример сериализации объекта `Person`:

```
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
 
namespace Serialization
{
    [Serializable]
    class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
 
        public Person(string name, int age)
        {
            Name = name;
            Age = age;
        }
    }
     
    class Program
    {
        static void Main(string[] args)
        {
            // объект для сериализации
            Person person = new Person("Tom", 29);
            Console.WriteLine("Объект создан");
 
            // создаем объект BinaryFormatter
            BinaryFormatter formatter = new BinaryFormatter();
            // получаем поток, куда будем записывать сериализованный объект
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                formatter.Serialize(fs, person);
 
                Console.WriteLine("Объект сериализован");
            }
 
            // десериализация из файла people.dat
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                Person newPerson = (Person)formatter.Deserialize(fs);
 
                Console.WriteLine("Объект десериализован");
                Console.WriteLine($"Имя: {newPerson.Name} --- Возраст: {newPerson.Age}");
            }
 
            Console.ReadLine();
        }
    }
}
```


### Сериализация в PHP

PHP использует в основном человекочитаемый строковый формат, в котором буквы представляют тип данных, а цифры - длину каждой записи. Например, рассмотрим объект User с атрибутами:

```=
$user->name = "carlos";
$user->isLoggedIn = true;
```

При сериализации этот объект может выглядеть примерно так:

```
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```

Это может быть интерпретировано следующим образом:

`O:4:"User"` - объект с 4-символьным именем класса "Пользователь".
`2` - объект имеет 2 атрибута
`s:4:"name"` - Ключом к первому атрибуту является 4-символьная строка `"name"`.
`s:6:"carlos"` - значение первого атрибута - 6-символьная строка `"carlos"`.
`s:10:"isLoggedIn"` - ключом второго атрибута является 10-символьная строка `"isLoggedIn"`.
`b:1` - значение второго атрибута является булевым значением `true`

Нативными методами сериализации PHP являются serialize() и unserialize(). Если у вас есть доступ к исходному коду, вам следует начать с поиска unserialize() в любом месте кода и продолжить исследование.

## Что такое небезопасная дезериализация?

Небезопасная десериализация - это когда контролируемые пользователем данные десериализуются веб-сайтом. Это потенциально позволяет злоумышленнику манипулировать сериализованными объектами с целью передачи вредоносных данных в код приложения.

Можно даже заменить сериализованный объект на объект совершенно другого класса. Тревожно, что объекты любого класса, доступные на сайте, будут десериализованы и инициализированны, независимо от того, какой класс ожидался. По этой причине небезопасная десериализация иногда называется уязвимостью "инъекции объекта".

Объект неожиданного класса может вызвать исключение. Однако к этому времени ущерб уже может быть нанесен. Многие атаки, основанные на десериализации, завершаются до завершения десериализации. Это означает, что сам процесс десериализации может инициировать атаку, даже если собственная функциональность сайта не взаимодействует напрямую с вредоносным объектом. По этой причине сайты, логика которых основана на сильно типизированных языках, также могут быть уязвимы для этих методов.

## Как возникают незащищенные уязвимости десериализации?

Небезопасная десериализация обычно возникает из-за общего непонимания того, насколько опасной может быть десериализация данных, контролируемых пользователем. В идеале, пользовательский ввод никогда не должен быть десериализован вообще.

Однако иногда владельцы сайтов думают, что они безопасны, потому что они реализуют какую-то дополнительную проверку десериализованных данных. Такой подход часто оказывается неэффективным, поскольку практически невозможно провести валидацию или санитизацию, чтобы учесть каждый случай. Эти проверки также имеют принципиальные недостатки, так как они полагаются на проверку данных после их десериализации, что во многих случаях будет слишком поздно для предотвращения атаки.

Уязвимости также могут возникать из-за того, что десериализованные объекты часто считаются надежными. Особенно при использовании языков с бинарным форматом сериализации разработчики могут подумать, что пользователи не могут эффективно читать данные или манипулировать ими. Однако, несмотря на то, что это может потребовать больше усилий, атакующий может использовать как двоичные объекты, так и строковые форматы.

## Ущерб от уязвимостей небезопасной десериализации

Воздействие небезопасной десериализации может быть очень серьезным, поскольку она является точкой входа в значительно увеличенную поверхность атаки. Она позволяет злоумышленнику повторно использовать существующий код приложения вредными способами, что приводит к многочисленным другим уязвимостям и часто к удаленному выполнению кода.

Даже в тех случаях, когда удаленное выполнение кода невозможно, небезопасная десериализация может привести к повышению привилегий, произвольному доступу к файлам и атакам типа "отказ в обслуживании".

## Как эксплуатируют уязвимости небезопасной десериализации?

Как было сказано ранее, все языки и библиотеки часто используют общие форматы сериализации, такие как JSON, XML или YAML, но наибольший интерес представляют языки и библиотеки, которые используют собственные форматы сериализации, которые предоставляют больше возможностей в этих специфических представлениях.

Из-за различий в процессах сериализации и десериализации, **эксплуатация таких уязвимостей целиком зависит от конкретных реализаций**. Мы **рассмотрим два весьма популярных примера** атак на десериализацию и упомянем остальные случаи, которые не редко встречаются в веб-приложениях.

Использование некоторых уязвимостей десериализации может быть таким же простым, как и **изменение атрибута в сериализованном объекте**. Поскольку состояние объекта сохраняется, вы можете изучить сериализованные данные, чтобы определить и отредактировать интересные значения атрибутов. Затем вы можете передать вредоносный объект на сайт через его десериализацию. Это первый шаг для базового эксплойта десериализации.

Однако небезопасная десериализация становится гораздо интереснее, когда вы создаете эксплойты, которые автоматически передают данные в опасные методы. Это становится возможным благодаря использованию "волшебных методов".

**Волшебные методы** - это специальное подмножество методов, которые вы не должны явно вызывать. Вместо этого они вызываются автоматически при наступлении определенного события или сценария. Волшебные методы - общая особенность объектно-ориентированного программирования на различных языках. Иногда они обозначаются префиксом или окружением имени метода двойным подчёркиванием.

**Наиболее важным** в этом контексте является то, что некоторые языки имеют **магические методы**, которые **вызываются автоматически** в процессе десериализации. Например, метод `unserialize()` в PHP ищет и вызывает магический метод `__wakeup()` объекта.

В десериализации Java то же самое относится и к методу `readObject()`, который, по сути, действует как конструктор для "повторной инициализации" сериализованного объекта. Метод `ObjectInputStream.readObject()` используется для чтения данных из исходного потока байт. Однако, классы, способные к сериализации, также могут объявлять свои собственные методы `readObject()` следующим образом:

```java
private void readObject(ObjectInputStream in) бросает IOException, ClassNotFoundException {...};
```

Это позволяет классу более точно контролировать десериализацию собственных полей. Крайне важно, что именно так объявленный метод `readObject()` действует как магический метод, который вызывается при десериализации.

:::info
Назовите несколько магических методов, которые вы знаете, и которые могут быть выполнены после десериализации строки в объект?
:::

Следует обратить пристальное внимание на любые классы, содержащие эти типы магических методов. Они позволяют передать данные из сериализованного объекта в код сайта до того, как объект будет полностью десериализован. Это является отправной точкой для создания более продвинутых эксплойтов.

### Цепочки гаджетов

"Гаджет" - это фрагмент кода, существующего в приложении, который может помочь злоумышленнику достичь определенной цели. Сам по себе гаджет не может напрямую сделать что-либо вредоносное при вводе пользователем. Однако, целью злоумышленника может быть просто обращение к методу, который передаст его ввод в другой гаджет. Связывая таким образом несколько гаджетов, атакующий может передать свою нагрузку в опасный "sink gadget", где он может нанести максимальный урон.

**Важно понимать**, что, в отличие от некоторых других видов эксплойтов, цепочка гаджетов не является полезной нагрузкой цепочки методов, построенных атакующим. **Весь код уже существует на сайте.** **Единственное, что контролируется злоумышленником - это данные**, которые передаются в цепочку гаджетов. Как правило, это делается с помощью магического метода, который вызывается при десериализации, иногда известного как **"стартовый гаджет"**.

В "дикой природе", многие незащищенные уязвимости десериализации могут быть использованы только с помощью цепочек гаджетов. Иногда это может быть простая одно- или двухступенчатая цепочка, но построение атак высокой надежности, скорее всего, потребует более сложной последовательности объектов и вызовов методов. Следовательно, возможность построения цепочек гаджетов является одним из ключевых аспектов успешной эксплуатации небезопасной десериализации.

### Работа с предварительно подготовленными цепочками гаджетов

Вручную идентифицировать цепочки гаджетов может быть довольно сложным процессом, и практически невозможно без доступа к исходному коду. К счастью, есть несколько вариантов работы с предварительно построенными цепочками гаджетов, которые можно попробовать сначала.

Есть несколько инструментов, которые могут помочь вам построить цепочки гаджетов с минимальными усилиями. Эти инструменты предоставляют ряд предварительно обнаруженных цепочек гаджетов, которые были использованы на других сайтах. Обнаружив незащищенную уязвимость десериализации на целевом сайте, вы можете использовать эти инструменты, чтобы попытаться ее использовать, даже если у Вас нет доступа к исходному коду. Такой подход стал возможен благодаря широкому использованию библиотек, содержащих эксплуатируемые цепочки гаджетов. Например, если цепочка гаджетов, основанная на библиотеке коллекций Java Apache Commons Collections, может быть использована на одном сайте, то любой другой сайт, реализующий эту библиотеку, также может быть использован с помощью той же самой цепочки.

Одним из таких инструментов для эксплойтов десериализации Java является "ysoserial". Вы просто указываете библиотеку, которую, по вашему мнению, использует целевое приложение, а затем предоставляете команду, которую хотите попробовать выполнить. Инструмент создает соответствующий сериализованный объект на основе известной ему цепочки гаджетов для данной библиотеки. При этом все равно требуется определенное количество проб и ошибок, но это значительно меньше трудозатрат, чем построение собственных цепочек гаджетов вручную.

### Атаки на сериализацию в Java

См. Упражнение 1

Для успешной атаки на десериализацию нам нужно изучить приложение и найти места где используются и обрабатываются сериализованные объекты. Затем подготовить нагрузку, которая запустит цепочку гаджетов и приведет к выполнению ожидаемого нами кода.

Для выполнения данной атаки вам потребуется ознакомиться с работой инструмента [ysoserial](https://github.com/frohoff/ysoserial) и применить его для генерации цепочки гаджетов под цель.

### Атаки на сериализацию в PHP

См. Упражнение 2

Атака не отличается от предыдущей по смыслу, но теперь вам нужно использовать новый инструмент генерации цепочек гаджетов для PHP - [PHPGGC](https://github.com/ambionics/phpggc).

## Как предотвращать уязвимости небезопасной десериализации?

Следует избегать десериализации пользовательского ввода, если в этом нет абсолютной необходимости. 

Если вам все же необходимо десериализовать данные из недоверенных источников, примените надежные меры, чтобы убедиться, что данные не были подделаны. Например, можно внедрить цифровую подпись для проверки целостности данных. Однако помните, что любые проверки должны проводиться до начала процесса десериализации. В противном случае они не принесут никакой пользы.

Если возможно, следует вообще избегать использования общих функций десериализации. Сериализованные данные этих методов содержат все атрибуты исходного объекта, включая приватные поля, которые потенциально содержат конфиденциальную информацию. Вместо этого, вы можете создать свои собственные методы сериализации для конкретного класса, чтобы, по крайней мере, контролировать, какие поля будут открыты.

Наконец, помните, что уязвимостью является десериализация пользовательского ввода, а не наличие цепочек гаджетов, которые впоследствии обрабатывают данные. Не полагайтесь на попытки устранить цепочки гаджетов, которые вы идентифицируете во время тестирования. 


## Дополнительные материалы

- [Java Deserialization Cheat Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet)
- [Java Unmarshaller Security](https://github.com/mbechler/marshalsec)
- [Инструмент для генерации полезной нагрузки, использующий небезопасную десериализацию объектов Java](https://github.com/frohoff/ysoserial)
- [PHPGGC: PHP Generic Gadget Chains](https://github.com/ambionics/phpggc)
- [Атаки на десериализацию JSON](https://github.com/mbechler/marshalsec)

## Упражнения

https://portswigger.net/web-security/deserialization

## Упражнение 1

Эксплуатация десериализации Java с помощью Apache Commons - https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons (Сложность: средняя)

## Упражнение 2

Эксплуатация десериализации PHP с предварительно построенной цепочкой гаджетов - https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain (Сложность: средняя)




