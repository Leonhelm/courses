<img width="1117" alt="изображение" src="https://github.com/Leonhelm/courses/assets/20487810/4d5249b3-a542-4a59-80f0-93bdcf9f0a4c"># Базовый курс школы архитекторов "Введение в архитектуру"

## 1. Архитектура и роль архитектора

### 1.1 Жизненный цикл продукта

Бизнес идея -> идея о реализации -> имплементация -> вывод в продакшн -> эксплуатация

Чем раньше мы обнаруживаем ошибку, тем дешевле её исправить.

### 1.2 Требования

Что бы не совершать ошибок надо собирать требования.

Функциональные требования

* Что делает система в определённый момент времени. Например, клиент должен получть имейл после регистрации;
* Форматы: тз, спецификация, юзер-стори.

Нефункциональные требования

* Как должна работать система. Например, клиент должен получить имейл после регистрации в течении пяти минут или какие протоколы шифрования нужно использовать для безопасности.

Ограничения

* Фундаментальные требования к системе обозначающие возможность её существования. Например, система должна соблюдать закон о персональных данных или ограничения по бюджету.

Требования будут противоречить друг другу. Например, безопасность, производительность и стоимость разработки всегда конфиликтуют между собой. Поэтому с требованиями нужно работать очень вниматьльно, необходимо их приоритезировать и понимать **архитектурно значимые требования**. Примеры архитектурно значимых требований:

* Требование имеет высокое значение для бизнеса;
* Требование несёт высокий технический риск;
* Требование влечёт создание нового компонента;
* Требование повышает SLA/QoS.

### 1.3 Источники требований

* Доменная область. Например понимание пиковой нагрузки на систему: праздники для интернет магазина;
* Регуляторы. Например, соблюдение законов страны в которой разрабатывается система;
* Среда. Например, облако, на котором живут все приложения заказчика;
* Стейкхолдеры – люди заинтересованные в проекте. Например: спонсор проекта, заказчик, команда разработки, конечные пользователи, конкуренты.

#### Классификация стейкхолдеров

По влиянию/интересу:

<img width="682" alt="изображение" src="https://github.com/Leonhelm/courses/assets/20487810/036f02cb-6f8f-4e61-806e-b3d8e2c3e630"><br />

По ролям, матрица RACI:

* Responsible (ответственный за работу) — тот, кто непосредственно выполняет задание;
* Accountable (ответственный за результат) — тот, кто принимает работу и несёт ответственность за результат;
* Consulted (консультирующий) — тот, кто оказывает консультативную помощь;
* Informed (информируемый) — тот, кто в курсе принимаемых решений и хода выполнения задачи.

### 1.4 Как определять стейкхолдеров и приоритизировать требования

Надо ответить на вопросы, некоторые из них:

* Кто выиграет от завершения проекта в нашей организации или за её пределами?
* Кто будет заниматься реализацией проекта?
* Кто будет принимать решения?
* Кто будет пользоваться результатом?
* На кого повлияет результат проекта?
* Кто из нашей организации связан с проектом?
* Какие гос. структуры связаны с проектом?
* Кто наша аудитория? Какие есть особенности этих людей?
* Какие профессиональные организации заинтересованы в проете?

Для приоритезации требований можно пользоваться упражнением **Utility tree**: формируем  список требований, зачастую с преобладанием нефункциональных, в правой части борда, затем классифицируем их в левую часть. В итоге необходимо каждое требование свести к двум свойствам: важность для бизнеса и/или влияние на архитектуру. В итоге получаем приоритеты по каждому требованию, список от наиболее к наименее важным:

1. Важное для бизнеса, невлияющие на архитектуру;
2. Важное для бизнеса, влияющие на архитектуру;
3. Неважное для бизнеса, невлияющие на архитектуру;
4. Неважное для бизнеса, влияющие на архитектуру.

Пример дерева:

<img width="1130" alt="изображение" src="https://github.com/Leonhelm/courses/assets/20487810/6f53490a-a99b-4128-85f2-7521a70154e6"><br />

#### Предположения

У всех требований есть нюанс – они никогда не бывают полными, потому что мир неопределённый и сложный. Всегда есть разумные допущения о неизвестном. Например, требование: приложение должно работать быстро, но без метрик мы не знаем насколько – делаем предположение, что система будет отвечать менее чем за одну секунду;

1.5 Заключение и рекомендации

Архитектура нужна, чтобы создать систему, отвечающую требованиям.

Один из основных источников требований: стейкхолдеры.

Архитектор идентифицирует стейкходлеров и собирает с них требования.

После получения требований архитектор делает предположения, проектирует систему и объясняет её всем стейкхолдерам.

Архитектор следит за реализацией и выпуском в продакшн.

Не бывает плохих архитектур, бывают архитектуры, которые не подходят под требования и/или слишком дорогие.

## 2. Подходы к работе с кодом

Развивая систему необходимо бороться со сложностью. Нельзя управлять тем, что невозможно измерить, но всё, что измеримо, можно достичь.

### 2.1 Парадигмы программирования

<img width="1117" alt="изображение" src="https://github.com/Leonhelm/courses/assets/20487810/ee7625e3-97b6-47d3-bc26-576351bed85c"><br />

#### Принципы модульности

Логическая группировка взаимосвязанного кода, который может быть структуирован в классах (ООП) или функциях (структурная или функциональная парадигма).

**Cohesion** – метрика, которая показывает до какой степени части модуля должны быть внутри одного модуля. Или в других словах – это мера того, как модули связаы друг с другом.

**Coupling** – степень взаимозависимости между модулями; мера того, как близко взаимосвязаны две функции из разных модулей; силя связи между модулями.

Cohesion про связи внутри компонента, coupling про связи между компонентами. Высокое значение сohesion это хорошо – сложность спрятана внутри компонента. Высокое значение coupling это плохо – компоненты жить друг без друга не могут, не стоило разделять компоненты.

**Connascense** – метрика, позволяющая размышлять о сложности, вызванной отношениями зависимости в ООП. ООП'шная версия coupling.

<img width="671" alt="изображение" src="https://github.com/Leonhelm/courses/assets/20487810/e71a1873-cf7b-4dfd-90bd-d5b2f6d319a2"><br />

##### SOLID

https://solidbook.vercel.app/

### 2.2 Паттерны и компоненты

### 2.3 Принципы организации компонентов

### 2.4 12-факторное приложение

### 2.5 Статья Александра Поломодова про подходы к организации кода 









